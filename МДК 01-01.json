[
    {
        "question": "Что такое ООП?",
        "choices": [
            "Объектно-ориентированное программирование — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.",
            "Объектно-ориентированное программирование — так называют любой тип программирования, в котором используются понятия высокого уровня и, в отличие от Assembler, в котором не работают напрямую с ячейками памяти ПК.",
            "Объектно-ориентированное программирование — просто красивое понятие. Если вдуматься, оно не несет дополнительной смысловой нагрузки, просто программисты любят аббревиатуры, так области их знаний выглядят сложнее.",
            "Очень одинокий программист."
        ],
        "correctAnswers": [
            "Объектно-ориентированное программирование — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования."
        ]
    },
    {
        "question": "Что такое класс в Java?",
        "choices": [
            "Уровень сложности программы. Все операторы делятся на классы в зависимости от сложности их использования.",
            "Базовый элемент объектно-ориентированного программирования в языке Java.",
            "Просто одно из возможных названий переменной.",
            "Такое понятие есть только в C++, в Java такого понятия нет."
        ],
        "correctAnswers": [
            "Базовый элемент объектно-ориентированного программирования в языке Java."
        ]
    },
    {
        "question": "Как объявить класс в коде?",
        "choices": [
            "class MyClass {}",
            "new class MyClass {}",
            "select * from class MyClass {}",
            "MyClass extends class {}"
        ],
        "correctAnswers": [
            "class MyClass {}"
        ]
    },
    {
        "question": "Что означает ключевое слово extends?",
        "choices": [
            "Что данный класс наследуется от другого.",
            "Что это дополнительный модуль класса, который расширяет его свойства.",
            "Что два класса делают одно и то же.",
            "Что это самый большой класс в программе."
        ],
        "correctAnswers": [
            "Что данный класс наследуется от другого."
        ]
    },
    {
        "question": "Что означает перегрузка метода в Java (overload).",
        "choices": [
            "Изменение поведения метода класса относительно родительского.",
            "Изменение поведения метода класса относительно дочернего.",
            "Несколько методов с одинаковым названием, но разным набором параметров.",
            "Несколько разных классов с одинаковым методом."
        ],
        "correctAnswers": [
            "Несколько методов с одинаковым названием, но разным набором параметров."
        ]
    },
    {
        "question": "Что означает переопределение метода в Java (override).",
        "choices": [
            "Изменение поведения метода класса относительно родительского.",
            "Изменение поведения метода класса относительно дочернего.",
            "Несколько методов с одинаковым названием, но разным набором параметров.",
            "Несколько разных классов с одинаковым методом."
        ],
        "correctAnswers": [
            "Изменение поведения метода класса относительно родительского."
        ]
    },
    {
        "question": "Чем отличаются static-метод класса от обычного метода класса.",
        "choices": [
            "Поведение обычного метода класса можно изменить в классе-наследнике, а поведение static-метода нельзя.",
            "Обычный метод класса можно переопределить, а static-метод нельзя.",
            "Обычный метод класса работает от объекта класса, а static-метод от всего класса.",
            "Static-метод класса можно вызывать только внутри класса, а обычный - в любой части кода."
        ],
        "correctAnswers": [
            "Обычный метод класса работает от объекта класса, а static-метод от всего класса."
        ]
    },
    {
        "question": "Как вызвать static-метод внутри обычного?",
        "choices": [
            "Никак, static-метод можно вызвать только от объекта класса.",
            "Можно, надо перед этим перегрузить обычный метод класса.",
            "Можно, надо перед этим переопределить обычный метод класса.",
            "Можно, ничего дополнительно делать не надо."
        ],
        "correctAnswers": [
            "Можно, ничего дополнительно делать не надо."
        ]
    },
    {
        "question": "Как вызвать обычный метод класса внутри static-метода?",
        "choices": [
            "Никак, static-метод не работает с объектом класса.",
            "Можно, надо перед этим перегрузить обычный метод класса.",
            "Можно, надо перед этим переопределить обычный метод класса.",
            "Можно, ничего дополнительно делать не надо."
        ],
        "correctAnswers": [
            "Никак, static-метод не работает с объектом класса."
        ]
    },
    {
        "question": "Для чего необходимо ключевое слово this",
        "choices": [
            "Это указатель на переопределенный метод класса. Его нельзя опускать при вызове, иначе переопределение не сработает.",
            "Это указатель на текущий объект класса внутри самого класса. Его можно опускать при вызове метода класса, но лучше этого не делать.",
            "Это не ключевое слово.",
            "Это ключевое слово для вызова обычного метода внутри static-метода. Его нельзя опускать, иначе вызов не сработает и будет ошибка."
        ],
        "correctAnswers": [
            "Это указатель на текущий объект класса внутри самого класса. Его можно опускать при вызове метода класса, но лучше этого не делать."
        ]
    },
    {
        "question": "Что вернет метод, объявленный следующим образом:\npublic static int getAmount()",
        "choices": [
            "Не ясно, надо смотреть код метода.",
            "Вернет static-поле класса.",
            "Вернет ссылку на объект класса this.",
            "Вернет целочисленное значение."
        ],
        "correctAnswers": [
            "Вернет целочисленное значение."
        ]
    },
    {
        "question": "Какой метод позволяет запустить программу на Java?",
        "choices": [
            "Любой, его можно задавать в настройках проекта",
            "Запуск программы происходит через компиляцию проекта, основного метода нет",
            "С класса, что был написан первым и с методов что есть внутри него",
            "С метода main в любом из классов"
        ],
        "correctAnswers": [
            "С метода main в любом из классов"
        ]
    },
    {
        "question": "Где правильно присвоено новое значение к многомерному массиву?",
        "choices": [
            "a{0}{0} = 1;",
            "a[0, 0] = 1;",
            "a[0 0] = 1;",
            "a(0)(0) = 1;",
            "a[0][0] = 1;"
        ],
        "correctAnswers": [
            "a[0][0] = 1;"
        ]
    },
    {
        "question": "Какие числа будут выведены?\n\nfor (int i = 10; i < 20; i += 2) {\n    if (i > 15)\n        break;\n    if (i % 4 == 0)\n        continue;\n    System.out.println (i);\n}",
        "choices": [
            "11, 13, 15",
            "14",
            "10, 12, 14",
            "12, 14",
            "10, 14"
        ],
        "correctAnswers": [
            "10, 14"
        ]
    },
    {
        "question": "Сколько параметров может принимать функция?",
        "choices": [
            "Не более 3",
            "Не более 10",
            "Не более 5",
            "Не более 20",
            "Неограниченное количество"
        ],
        "correctAnswers": [
            "Неограниченное количество"
        ]
    },
    {
        "question": "Что выведет этот код?\nint a = 9;\nswitch (a) {\n    case 0: System.out.print (\"0\");\n    case 5: System.out.print (\"5\"); break;\n    case 9: System.out.print (\"9\");\n    case 10: System.out.print (\"10\"); break;\n    default: System.out.print (\"!\");\n}",
        "choices": [
            "Ошибка в коде",
            "9",
            "10",
            "910!",
            "910"
        ],
        "correctAnswers": [
            "910"
        ]
    },
    {
        "question": "Какой класс отвечает за получение информации от пользователя?",
        "choices": [
            "System",
            "Get",
            "Scaner",
            "Out",
            "Scanner"
        ],
        "correctAnswers": [
            "Scanner"
        ]
    },
    {
        "question": "В чем здесь ошибка?\n\nint a, b;\nSystem.out.print(\"Введите первое число: \");\nScanner num = new Scanner(System.in);\na = num.nextFloat ();",
        "choices": [
            "Ошибок нет",
            "Вместо System.in надо использовать System.out",
            "int a, b - необходимо записывать по отдельности",
            "Вместо nextFloat надо использовать nextInt"
        ],
        "correctAnswers": [
            "Вместо nextFloat надо использовать nextInt"
        ]
    },
    {
        "question": "Где правильно создана простая переменная?",
        "choices": [
            "byte x = 100000;",
            "int[] a;",
            "char str = 'ab';",
            "bool isDone = true;",
            "float x = 23.3f;"
        ],
        "correctAnswers": [
            "float x = 23.3f;"
        ]
    },
    {
        "question": "Каждый файл должен называется...",
        "choices": [
            "как вам захочется",
            "по имени основного метода в нем",
            "по имени названия пакета",
            "по имени первой библиотеки в нём",
            "по имени класса в нём"
        ],
        "correctAnswers": [
            "по имени класса в нём"
        ]
    },
    {
        "question": "Где правильно осуществлен вывод?",
        "choices": [
            "System.print(''Hello World!'');",
            "System.out(''Hello World!'');",
            "print(''Hello World!'');",
            "System.out.print = ''Hello World!'';",
            "System.out.print(''Hello World!'');"
        ],
        "correctAnswers": [
            "System.out.print(''Hello World!'');"
        ]
    },
    {
        "question": "Какие математические операции есть в Java?",
        "choices": [
            "+, -, *, /",
            "+, -, *, /, %",
            "+, -, *, /, --, ++",
            "Все перечисленные"
        ],
        "correctAnswers": [
            "Все перечисленные"
        ]
    },
    {
        "question": "Где правильно создан массив?",
        "choices": [
            "int a = new int[] {1, 2, 3, 4, 5};",
            "int[] a = new int {1, 2, 3, 4, 5};",
            "int a[] = 1, 2, 3, 4, 5;",
            "int[] a = int[] {1, 2, 3, 4, 5};",
            "int[] a = new int[] {1, 2, 3, 4, 5};"
        ],
        "correctAnswers": [
            "int[] a = new int[] {1, 2, 3, 4, 5};"
        ]
    },
    {
        "question": "Что выведет этот код?\nint a = 9;\nboolean isDone = false;\nif (a % 3 != 0 || !isDone)   \n    System.out.print(\"Готово\");",
        "choices": [
            "Ошибку в коде",
            "Ничего не будет выведено в консоль",
            "Выведет текст: ''Готово''"
        ],
        "correctAnswers": [
            "Выведет текст: ''Готово''"
        ]
    },
    {
        "question": "Что общего у всех элементов массива?",
        "choices": [
            "Их названия",
            "Их размер",
            "Их адрес в памяти",
            "Их тип данных"
        ],
        "correctAnswers": [
            "Их тип данных"
        ]
    },
    {
        "question": "Для чего можно использовать Java?",
        "choices": [
            "Для создания сайтов",
            "Для создания программ под ПК",
            "Для создания игр",
            "Только для создания игр и программ",
            "Для всего перечисленного"
        ],
        "correctAnswers": [
            "Для всего перечисленного"
        ]
    },
    {
        "question": "что такое Java?",
        "choices": [
            "Мотоцикл",
            "Остров",
            "Сигареты",
            "Язык программирования",
            "Чай"
        ],
        "correctAnswers": [
            "Язык программирования"
        ]
    },
    {
        "question": "Что будет в результате выполнения операции 2 + 2 == 5 && 12 / 4 == 3 || 2 == 5 % 3?",
        "choices": [
            "true",
            "false",
            "null",
            "0"
        ],
        "correctAnswers": [
            "true"
        ]
    },
    {
        "question": "Отметьте верное утверждение относительно языков Java и JavaScript:",
        "choices": [
            "оба языка кроссплатформенны",
            "их спецификации являются закрытыми",
            "JavaScript является синонимом Java"
        ],
        "correctAnswers": [
            "оба языка кроссплатформенны"
        ]
    },
    {
        "question": "Что будет выведено на экран в результате выполнения следующего кода: public class SomeClass { static int x = 5; public static void main(String[] args) { int x; int y = 5; if (y > 3) x = 1; System.out.println(x); } }",
        "choices": [
            "1",
            "3",
            "5",
            "предупреждение о потенциальной ошибке",
            "сообщение об ошибке компиляции"
        ],
        "correctAnswers": [
            "сообщение об ошибке компиляции"
        ]
    },
    {
        "question": "Как получить объект класса Color из AWT, описывающий чистый синий цвет?",
        "choices": [
            "new Color(''blue'')",
            "new Color(0, 0, 255)",
            "Color.getBlue()",
            "Color.blue"
        ],
        "correctAnswers": [
            "new Color(0, 0, 255)",
            "Color.blue"
        ]
    },
    {
        "question": "Каким образом на однопроцессорной машине исполняются многопоточные приложения?",
        "choices": [
            "на однопроцессорном компьютере многопоточные приложения не исполняются",
            "количество процессоров для многопоточной архитектуры не имеет значения",
            "рабочее время процессора разбивается на небольшие интервалы, в течение которых выполняется одна задача, после чего происходит переключение на следующую задачу"
        ],
        "correctAnswers": [
            "рабочее время процессора разбивается на небольшие интервалы, в течение которых выполняется одна задача, после чего происходит переключение на следующую задачу"
        ]
    },
    {
        "question": "Какие классы из пакета java.util предназначены для работы с датами?",
        "choices": [
            "java.util.Date",
            "java.util.Time",
            "java.util.Calendar",
            "java.util.DateTime",
            "java.util.GregorianCalendar"
        ],
        "correctAnswers": [
            "java.util.Date",
            "java.util.Calendar",
            "java.util.GregorianCalendar"
        ]
    },
    {
        "question": "Какие источники могут использоваться классами стандартных входных потоков java в качестве источника данных?",
        "choices": [
            "файл – представляется объектом класса File",
            "массив – представляется массивом byte[] или char[]",
            "строка – представляется объектом byte[]",
            "строка – представляется объектом String",
            "таблица базы данных - представляется массивом Object[]"
        ],
        "correctAnswers": [
            "файл – представляется объектом класса File",
            "массив – представляется массивом byte[] или char[]",
            "строка – представляется объектом String"
        ]
    },
    {
        "question": "Назовите сете-зависимые уровни модели OSI",
        "choices": [
            "уровень приложений",
            "представительский уровень",
            "сессионный уровень",
            "физический уровень",
            "сетевой уровень"
        ],
        "correctAnswers": [
            "физический уровень",
            "сетевой уровень"
        ]
    },
    {
        "question": "Почему объектно-ориентированное программирование пришло на смену процедурному программированию?",
        "choices": [
            "программы, написанные с использованием ООП, выполняются на компьютере быстрее",
            "использование ООП позволяет создавать не зависящие от платформы программы",
            "ООП позволяет уменьшить сложность создания ПО",
            "ООП позволяет увеличить надежность создаваемого ПО"
        ],
        "correctAnswers": [
            "ООП позволяет уменьшить сложность создания ПО",
            "ООП позволяет увеличить надежность создаваемого ПО"
        ]
    },
    {
        "question": "Как записать в Java-программе символ с кодом546 (код символа десятичный)?",
        "choices": [
            "'546'",
            "\\u0546",
            "\\u0222",
            "\\0222",
            "'222'"
        ],
        "correctAnswers": [
            "\\u0222"
        ]
    },
    {
        "question": "Какие варианты объявления целочисленной переменной верны (никакие переменные предварительно не объявлены)?",
        "choices": [
            "int a = b;",
            "int a;",
            "int a = 5;",
            "int a = b = 5;",
            "int a = 5, b = a;"
        ],
        "correctAnswers": [
            "int a;",
            "int a = 5;",
            "int a = 5, b = a;"
        ]
    },
    {
        "question": "Какое из перечисленных ниже имен является простым? MyClass MyClass.name MyClass.name.toString() MyClass.name.toString().hashCode()",
        "choices": [
            "MyClass",
            "MyClass.name",
            "MyClass.name.toString()",
            "MyClass.name.toString().hashCode()",
            "ни один из перечисленных"
        ],
        "correctAnswers": [
            "MyClass"
        ]
    },
    {
        "question": "Какие модификаторы позволяют обращаться к элементу класса из классов-наследников того же пакета?",
        "choices": [
            "public",
            "protected",
            "по умолчанию",
            "private"
        ],
        "correctAnswers": [
            "public",
            "protected",
            "по умолчанию"
        ]
    },
    {
        "question": "Укажите количество преобразований, которые будут сделаны в следующем коде: long a = 3; a = 5 + 'A' + a;",
        "choices": [
            "0",
            "1",
            "2",
            "3",
            "4"
        ],
        "correctAnswers": [
            "3"
        ]
    },
    {
        "question": "Предположим, вы моделируете автомобиль, описывая его свойства в формате Java-класса. Какие из следующих полей нужно объявить динамическими?",
        "choices": [
            "идентификационный номер (VIN)",
            "максимально допустимая масса для этого класса автомобилей",
            "дата начала выпуска автомобилей",
            "дата выпуска автомобиля"
        ],
        "correctAnswers": [
            "идентификационный номер (VIN)",
            "дата выпуска автомобиля"
        ]
    },
    {
        "question": "Какое утверждение относительно языка Java верно?",
        "choices": [
            "он является только компилируемым",
            "он является только интерпретируемым",
            "он является и компилируемым, и интерпретируемым",
            "ни одно из перечисленных"
        ],
        "correctAnswers": [
            "он является и компилируемым, и интерпретируемым"
        ]
    },
    {
        "question": "Какие утверждения относительно класса java.awt.Container верны?",
        "choices": [
            "является наследником java.awt.Component",
            "добавляемые компоненты хранятся в упорядоченном списке",
            "для удаления всех компонентов из контейнера служит метод clearAll()",
            "контейнеры могут быть вложены друг в друга"
        ],
        "correctAnswers": [
            "является наследником java.awt.Component",
            "добавляемые компоненты хранятся в упорядоченном списке",
            "контейнеры могут быть вложены друг в друга"
        ]
    },
    {
        "question": "Для чего служит в Java класс Thread?",
        "choices": [
            "для запуска потоков",
            "для синхронизации потоков",
            "для изменения свойств (например, приоритета) потоков",
            "для прерывания потоков"
        ],
        "correctAnswers": [
            "для запуска потоков",
            "для синхронизации потоков",
            "для изменения свойств (например, приоритета) потоков",
            "для прерывания потоков"
        ]
    },
    {
        "question": "Какие утверждения относительно метода equals верны?",
        "choices": [
            "для любой объектной ссылки x, отличной от null, вызов x.equals(x) возвращает false",
            "реализация этого метода в классе Object вернет true только в случае равенства по ссылке",
            "метод equals может быть переопределен любым способом",
            "для любых объектных ссылок x и y многократные последовательные вызовы x.equals(y) возвращают одно и то же значение",
            "для любой не равной null объектной ссылки x вызов x.equals(null) должен вернуть значение true"
        ],
        "correctAnswers": [
            "реализация этого метода в классе Object вернет true только в случае равенства по ссылке",
            "метод equals может быть переопределен любым способом",
            "для любых объектных ссылок x и y многократные последовательные вызовы x.equals(y) возвращают одно и то же значение"
        ]
    },
    {
        "question": "Какие утверждения относительно класса TimeZone верны?",
        "choices": [
            "можно создавать экземпляры этого класса",
            "чтобы получить настройки текущей временной зоны надо использовать метод getDefault()",
            "чтобы получить настройки текущей временной зоны надо использовать метод getTimezone()",
            "позволяет получить список всех доступных временных зон"
        ],
        "correctAnswers": [
            "чтобы получить настройки текущей временной зоны надо использовать метод getDefault()",
            "позволяет получить список всех доступных временных зон"
        ]
    },
    {
        "question": "Что произойдет при попытке к одному объекту PipedWriter несколько раз присоединять объектыPipedReader?",
        "choices": [
            "при попытке присоединить более одного PipedReader будет брошено исключение IOException, но только в том случае, если предпринята попытка присоединить PipedReader, отличный от уже подключенного",
            "при попытке присоединить более одного PipedReader будет брошено исключение IOException, даже в том случае, если производится попытка несколько раз присоединить один и тот же объект PipedReader",
            "ничего не произойдет, так как это допустимая ситуация",
            "ничего из перечисленного"
        ],
        "correctAnswers": [
            "при попытке присоединить более одного PipedReader будет брошено исключение IOException, даже в том случае, если производится попытка несколько раз присоединить один и тот же объект PipedReader"
        ]
    },
    {
        "question": "Какой из вариантов является строчным комментарием?",
        "choices": [
            "// комментарий",
            "/* комментарий",
            "/* комментарий */",
            "/** комментарий */",
            "ни один из перечисленных"
        ],
        "correctAnswers": [
            "// комментарий"
        ]
    },
    {
        "question": "Укажите результат выполнения следующего фрагмента кода:\nint a = 5, b = 6;\na = b++;\nSystem.out.println(a);",
        "choices": [
            "5",
            "6",
            "7",
            "будет выдано сообщение об ошибке",
            "ничего из перечисленного"
        ],
        "correctAnswers": [
            "6"
        ]
    },
    {
        "question": "Какие утверждения относительно пакетов в Java верны?",
        "choices": [
            "каждый пакет может включать вложенные пакеты",
            "пакет, содержащий вложенный пакет, не может содержать классы",
            "пакеты могут содержать классы и интерфейсы",
            "каждый пакет имеет свое пространство имен",
            "разные пакеты могут разделять одно пространство имен"
        ],
        "correctAnswers": [
            "каждый пакет может включать вложенные пакеты",
            "пакеты могут содержать классы и интерфейсы",
            "каждый пакет имеет свое пространство имен"
        ]
    },
    {
        "question": "Для каких элементов в Java можно указать модификатор доступа?",
        "choices": [
            "для конструкторов класса",
            "для элементов ссылочных типов",
            "для пакетов",
            "для типов (классов и интерфейсов) объявления верхнего уровня"
        ],
        "correctAnswers": [
            "для конструкторов класса",
            "для элементов ссылочных типов",
            "для типов (классов и интерфейсов) объявления верхнего уровня"
        ]
    },
    {
        "question": "Какие утверждения относительно преобразования примитивных типов верны?",
        "choices": [
            "расширение - это переход от менее емкого типа к более емкому",
            "расширение является небезопасным преобразованием",
            "тип boolean можно привести к типу byte",
            "тип byte можно привести к типу int без потери данных",
            "тип byte можно привести к типу char без потери данных"
        ],
        "correctAnswers": [
            "расширение - это переход от менее емкого типа к более емкому",
            "тип byte можно привести к типу int без потери данных"
        ]
    },
    {
        "question": "Какие из следующих утверждений верны?",
        "choices": [
            "в Java существует всего 8 типов данных, которые не являются объектами",
            "в Java все типы данных являются объектами",
            "простые типы могут быть объектами",
            "ссылочные типы могут быть объектами"
        ],
        "correctAnswers": [
            "в Java существует всего 8 типов данных, которые не являются объектами",
            "ссылочные типы могут быть объектами"
        ]
    },
    {
        "question": "Есть следующий код:\npublic class SomeClass {\npublic static void main(String[] args) {\nSomeClass t = new SomeClass();\n____\n}\nprivate int check(String x, int n) {\nif (n == 0) return n;\nelse if (n == 1) {\nif (x != null) return 5;\n}\nelse if (n == 2 && x != null) {\nif (x.equals(\"YES\")) return 3;\nelse if (x.equals(\"NO\")) return 4;\n}\nreturn -1;\n}\n}\nЕсли вместо знаков подчеркивания поместить код вызова метода check, то какое из предложений будет верным?",
        "choices": [
            "t.check(''ANY'',1), в этом случае функция вернет значение 14",
            "t.check(''NO'',2), в этом случае функция вернет значение 4",
            "t.check(''YES'',1), в этом случае функция вернет значение 3",
            "t.check(''YES'',2), в этом случае функция вернет значение 4",
            "t.check(''ANY'',6), в этом случае функция вернет значение -1"
        ],
        "correctAnswers": [
            "t.check(''NO'',2), в этом случае функция вернет значение 4",
            "t.check(''ANY'',6), в этом случае функция вернет значение -1"
        ]
    },
    {
        "question": "Какой метод нужно вызвать, чтобы инициировать перерисовку компонента?",
        "choices": [
            "paint",
            "update",
            "repaint",
            "show"
        ],
        "correctAnswers": [
            "repaint"
        ]
    },
    {
        "question": "Поскольку интерфейс Runnable представляет собой альтернативный способ программирования потоков исполнения, можно ли в такой программе обойтись без класса Thread?",
        "choices": [
            "да",
            "да, если не модифицировать свойства потока (приоритет и т.п.)",
            "да, если не прерывать поток",
            "да, если не требуется взаимодействие с другими потоками",
            "нет"
        ],
        "correctAnswers": [
            "нет"
        ]
    },
    {
        "question": "В чем особенность класса-обертки для void?",
        "choices": [
            "никаких отличительных особенностей нет",
            "этот класс, в отличие от остальных классов-оберток, не реализует интерфейс java.io.Serializable",
            "он не имеет открытого конструктора. Более того, экземпляр этого класса вообще не может быть получен",
            "пакете java.lang отсутствует класс java.lang.Void"
        ],
        "correctAnswers": [
            "этот класс, в отличие от остальных классов-оберток, не реализует интерфейс java.io.Serializable",
            "он не имеет открытого конструктора. Более того, экземпляр этого класса вообще не может быть получен"
        ]
    },
    {
        "question": "В JDK 1.2 введены новые классы и интерфейсы, которые позволяют работать с наборами объектов. Отметьте те из них, которые являются интерфейсами.",
        "choices": [
            "java.util.List",
            "java.util.TreeMap",
            "java.util.AbstractList",
            "java.util.SortedMap",
            "java.util.Iterator"
        ],
        "correctAnswers": [
            "java.util.List",
            "java.util.SortedMap",
            "java.util.Iterator"
        ]
    },
    {
        "question": "Если вызвать write(0x01234567) у экземпляра OutputStream, то в каком порядке и какие байты будут записаны в выходной поток?",
        "choices": [
            "0x01,0x23,0x45,0x67",
            "0x67,0x45,0x23,0x01",
            "только 0x01",
            "только 0x67"
        ],
        "correctAnswers": [
            "только 0x67"
        ]
    },
    {
        "question": "Что такое класс?",
        "choices": [
            "семантическая и синтаксическая конструкция в коде программы, используемая для специфицирования услуг, предоставляемых объектом",
            "конструкция , позволяющая содержать в себе набор переменных различных типов",
            "некоторая сущность в виртуальном пространстве, обладающая определённым состоянием и поведением",
            "шаблон поведения объектов определенного типа с заданными параметрами, определяющими состояние"
        ],
        "correctAnswers": [
            "шаблон поведения объектов определенного типа с заданными параметрами, определяющими состояние"
        ]
    },
    {
        "question": "Дан следующий класс:\nclass abcPoint {\nabcPoint(int a, int b) {\nx = a;\ny = b;\n}\nint x, y;\n...\n}\nУкажите результат выполнения следующего фрагмента кода:\nabcPoint p = new abcPoint(5,3), p1 = p;\np.x = 4;\nSystem.out.println(p1.x);",
        "choices": [
            "3",
            "4",
            "5",
            "будет выдано сообщение об ошибке",
            "ничего из перечисленного"
        ],
        "correctAnswers": [
            "4"
        ]
    },
    {
        "question": "Вы создали класс Animal в пакете ru.animal. Где будет хранится исходный код класса в файловой системе?",
        "choices": [
            "ru\\animal\\Animal.java",
            "ru\\Animal.java",
            "ru\\animal\\Animal.class",
            "ru\\Animal.class",
            "ru\\animal\\Animal"
        ],
        "correctAnswers": [
            "ru\\animal\\Animal.java"
        ]
    },
    {
        "question": "Какие утверждения относительно заголовка класса верны?",
        "choices": [
            "допустимые модификаторы доступа для класса - public или default",
            "класс может быть объявлен как final",
            "допустимо наследовать final-класс",
            "допустима следующая цепочка наследования: A наследует классу B, B наследует классу C, C наследует классу A",
            "если не указан класс-предок класса, то это означает, что класс наследует от java.lang.Object"
        ],
        "correctAnswers": [
            "допустимые модификаторы доступа для класса - public или default",
            "класс может быть объявлен как final",
            "если не указан класс-предок класса, то это означает, что класс наследует от java.lang.Object"
        ]
    },
    {
        "question": "Будет ли скомпилирован следующий пример:\nbyte b = 100 - 100;\nb = 100 + 200;\nb = 100 * 100;",
        "choices": [
            "пример не будет скомпилирован, будет выдано сообщение об ошибках в 1-й и 2-й строках",
            "пример не будет скомпилирован, будет выдано сообщение об ошибках во 2-й и 3-й строках",
            "пример не будет скомпилирован, будет выдано сообщение об ошибках в 1-й и 3-й строках",
            "пример не будет скомпилирован, будет выдано сообщение об ошибках в 1-й, 2-й и 3-й строках",
            "пример будет скомпилирован"
        ],
        "correctAnswers": [
            "пример не будет скомпилирован, будет выдано сообщение об ошибках во 2-й и 3-й строках"
        ]
    },
    {
        "question": "Сколько объектов порождается при инициализации массива new int[3][4]?",
        "choices": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correctAnswers": [
            "4"
        ]
    },
    {
        "question": "Какие утверждения относительно виртуальной машины Java (Java Virtual Machine) верны?",
        "choices": [
            "позволяет отсекать опасный код на каждом этапе работы",
            "периодически запускает сборщик мусора",
            "для запуска приложения на языке Java на какой-либо операционной системе, для нее должна быть создана виртуальная машина",
            "поддерживает запуск приложений из файлов с расширением .java"
        ],
        "correctAnswers": [
            "позволяет отсекать опасный код на каждом этапе работы",
            "периодически запускает сборщик мусора",
            "для запуска приложения на языке Java на какой-либо операционной системе, для нее должна быть создана виртуальная машина"
        ]
    },
    {
        "question": "Что будет выведено на экран в результате выполнения следующего кода:\npublic class SomeClass {\npublic static void main(String[] args) {\nSomeClass t = new SomeClass();\nt.say(1);\n}\nprivate void say(int digit) {\nswitch (digit) {\ncase 1:\nSystem.out.print(\"1\");\nbreak;\ncase 2:\nSystem.out.print(\"2\");\ncase 3:\nSystem.out.print(\"3\");\ndefault:\nSystem.out.print(\"Unknown\");\n}\n}\n}",
        "choices": [
            "1",
            "2",
            "3",
            "Unknown",
            "ошибка времени выполнения"
        ],
        "correctAnswers": [
            "1"
        ]
    },
    {
        "question": "Сколько вложенных компонентов может быть у контейнера ScrollPane?",
        "choices": [
            "0",
            "1 любую компоненту",
            "1 любую компоненту и 1 контейнер ScrollPane",
            "произвольное количество"
        ],
        "correctAnswers": [
            "1 любую компоненту"
        ]
    },
    {
        "question": "Для чего нужна синхронизация?",
        "choices": [
            "для одновременного запуска нескольких потоков",
            "для того, чтобы потоки могли работать с общими данными предсказуемым образом",
            "для того, чтобы потоки могли приостанавливать друг друга",
            "для того, чтобы потоки могли запускать друг друга"
        ],
        "correctAnswers": [
            "для того, чтобы потоки могли работать с общими данными предсказуемым образом"
        ]
    },
    {
        "question": "Какие утверждения относительно класса Math верны?",
        "choices": [
            "от этого класса нельзя унаследоваться",
            "является абстрактным",
            "нельзя создать экземпляр этого класса",
            "содержит только статические методы"
        ],
        "correctAnswers": [
            "от этого класса нельзя унаследоваться",
            "нельзя создать экземпляр этого класса",
            "содержит только статические методы"
        ]
    },
    {
        "question": "Какой из перечисленных ниже классов имеет наибольшее сходство с классомVector?",
        "choices": [
            "AbstractCollection.",
            "ArrayList",
            "Hashtable",
            "TreeSet",
            "LinkedList"
        ],
        "correctAnswers": [
            "ArrayList"
        ]
    },
    {
        "question": "Какие утверждения относительно класса BufferedOutputStream верны?",
        "choices": [
            "предоставляет возможность производить многократную запись небольших блоков данных без обращения к устройству вывода",
            "запись с использованием буфера значительно быстрее, чем без него",
            "инициирование передачи содержимого буфера на устройство вывода осуществляется самим классом BufferedOutputStream",
            "инициирование передачи содержимого буфера на устройство вывода можно осуществить явным образом"
        ],
        "correctAnswers": [
            "предоставляет возможность производить многократную запись небольших блоков данных без обращения к устройству вывода",
            "запись с использованием буфера значительно быстрее, чем без него"
        ]
    },
    {
        "question": "Что используется для описания поведения объекта?",
        "choices": [
            "поля",
            "методы",
            "наследование",
            "инкапсуляция"
        ],
        "correctAnswers": [
            "методы"
        ]
    },
    {
        "question": "Отметьте ключевые слова языка Java:",
        "choices": [
            "yes",
            "nil",
            "goto",
            "const",
            "var"
        ],
        "correctAnswers": [
            "goto",
            "const"
        ]
    },
    {
        "question": "Какие существуют примитивные целочисленные типы?",
        "choices": [
            "byte",
            "float",
            "short",
            "boolean"
        ],
        "correctAnswers": [
            "byte",
            "short"
        ]
    },
    {
        "question": "Какие утверждения относительно модуля компиляции верны?",
        "choices": [
            "хранится в текстовом .java-файле",
            "отсутствие объявления пакета в модуле компиляции вызовет ошибку компиляции",
            "объявления верхнего уровня содержат объявление только одного типа",
            "если в модуле компиляции есть объявление пакета - оно будет первым выражением",
            "import-выражения позволяют импортировать типы в модуль компиляции и далее обращаться к ним по простым именам"
        ],
        "correctAnswers": [
            "хранится в текстовом .java-файле",
            "если в модуле компиляции есть объявление пакета - оно будет первым выражением",
            "import-выражения позволяют импортировать типы в модуль компиляции и далее обращаться к ним по простым именам"
        ]
    },
    {
        "question": "Какие утверждения относительно полей класса верны?",
        "choices": [
            "допускаются поля с одинаковыми именами, но с разными типами",
            "объявление полей начинается с перечисления модификаторов",
            "поле может быть проинициализировано только в конструкторе",
            "допускается инициализация final полей в конструкторе класса"
        ],
        "correctAnswers": [
            "объявление полей начинается с перечисления модификаторов",
            "допускается инициализация final полей в конструкторе класса"
        ]
    },
    {
        "question": "Какие утверждения относительно преобразования ссылочных типов верны?",
        "choices": [
            "преобразование от null-типа к любому объектному типу является расширяющим",
            "преобразование от класса A к классу B, если A наследуется от B является сужающим",
            "можно преобразовать ссылку одного типа к ссылке другого типа даже если они не являются родителем и наследником",
            "всегда можно обращаться к объекту, порожденному от наследника, по типу его родителя"
        ],
        "correctAnswers": [
            "преобразование от null-типа к любому объектному типу является расширяющим",
            "всегда можно обращаться к объекту, порожденному от наследника, по типу его родителя"
        ]
    },
    {
        "question": "Что будет выведено на экран в результате выполнения следующего кода: \npublic class SomeClass { \n int b = this.a; \n int a = 5; \n { \n  System.out.print(a); \n  System.out.print(b); \n } \n public static void main(String[] args) { \n  new SomeClass(); \n } \n}",
        "choices": [
            "00",
            "05",
            "50",
            "55"
        ],
        "correctAnswers": [
            "50"
        ]
    },
    {
        "question": "Какое утверждение относительно приведения массивов верно",
        "choices": [
            "любые массивы приводимы, поскольку являются объектами",
            "A[] можно привести к B[], если A приводится к B, и A, B – ссылочные типы",
            "массивы не преобразовываются",
            "A[] можно привести кB[], если A приводится к B"
        ],
        "correctAnswers": [
            "A[] можно привести к B[], если A приводится к B, и A, B – ссылочные типы"
        ]
    },
    {
        "question": "Какие утверждения относительно Java Development Kit (JDK) и Java Runtime Environment (JRE) верны?",
        "choices": [
            "JRE включает в себя средства разработки",
            "JDK включает в себя компилятор",
            "JDK не позволяет запускать программы",
            "JRE является минимальной реализацией виртуальной машины",
            "JRE включает в себя JDK"
        ],
        "correctAnswers": [
            "JDK включает в себя компилятор",
            "JRE является минимальной реализацией виртуальной машины"
        ]
    },
    {
        "question": "Что будет выведено на экран в результате выполнения следующего кода: \npublic class SomeClass { \n public static void main(String[] args) { \n  int i = 0; \n  while (i < 6) { \n   if (i > 5) i--; \n   if (i < 4) i++; \n   if (i == 5) i++; \n   i++; \n   System.out.print(i); \n  } \n } \n}",
        "choices": [
            "1234",
            "245",
            "2457",
            "3457"
        ],
        "correctAnswers": [
            "2457"
        ]
    },
    {
        "question": "Укажите результат выполнения следующего кода: \npublic abstract class SomeClass implements Runnable { \n public final static Object one = new Object(), two = new Object(); \n public static void main(String s[]) { \n  Thread t1 = new Thread() { \n   public void run() { \n    synchronized (one) { \n     try { \n      Thread.sleep(1000); \n     } catch (InterruptedException e) { \n      e.printStackTrace(); \n     } \n     synchronized (two) { \n      System.out.print(\"1\"); \n     } \n    } \n   } \n  }; \n  Thread t2 = new Thread() { \n   public void run() { \n    synchronized (two) { \n     synchronized (one) { \n      System.out.print(\"2\"); \n     } \n    } \n   } \n  }; \n  t1.start(); \n  t2.start(); \n } \n}",
        "choices": [
            "программа не завершит работу, на консоли появится 1",
            "программа не завершит работу, на консоли появится 2",
            "программа не завершит работу",
            "программа не завершит работу, на консоли появится 12"
        ],
        "correctAnswers": [
            "программа не завершит работу"
        ]
    },
    {
        "question": "Какие утверждения относительно класса ClassLoader верны?",
        "choices": [
            "от этого класса нельзя наследовать",
            "является неабстрактным",
            "каждый объект Class содержит ссылку на объект ClassLoader, с помощью которого он был загружен",
            "можно реализовать свой загрузчик, унаследовав его от ClassLoader"
        ],
        "correctAnswers": [
            "каждый объект Class содержит ссылку на объект ClassLoader, с помощью которого он был загружен",
            "можно реализовать свой загрузчик, унаследовав его от ClassLoader"
        ]
    },
    {
        "question": "Какие утверждения относительно java.util.Observer и java.util.Observable корректны?",
        "choices": [
            "Observer является классом, реализующим интерфейс Observable",
            "интерфейс Observer определяет всего один метод, update (Observable o, Object arg), который вызывается, когда обозреваемый объект изменяется",
            "обозреватели должны реализовать интерфейс Observable",
            "порядок, в котором вызываются методы update обозревателей, заранее не определен",
            "из-за отсутствия множественного наследования использовать Observer неудобно"
        ],
        "correctAnswers": [
            "интерфейс Observer определяет всего один метод, update (Observable o, Object arg), который вызывается, когда обозреваемый объект изменяется",
            "порядок, в котором вызываются методы update обозревателей, заранее не определен",
            "из-за отсутствия множественного наследования использовать Observer неудобно"
        ]
    },
    {
        "question": "Что произойдет, если, используя ByteArrayOutputStream, записать в файл значения типов long, int, byte именно в таком порядке, а считать в обратном, используя DataInputStream?",
        "choices": [
            "ошибка на этапе компиляции, так как нельзя настраивать DataInputStream на данные, записанные с помощью ByteArrayOutputStream",
            "несоответствие форматов ByteArrayOutputStream и DataInputStream проявится только во время выполнения, что приведет к возникновению исключения IOException",
            "все пройдет успешно, но полученные значения byte, int и long могут отличаться от тех, которые были записаны",
            "все пройдет успешно, полученные значения byte, int и long не будут отличаться от тех, которые были записаны"
        ],
        "correctAnswers": [
            "все пройдет успешно, но полученные значения byte, int и long могут отличаться от тех, которые были записаны"
        ]
    },
    {
        "question": "Какие возможны отношения между классами?",
        "choices": [
            "агрегация",
            "полиморфизм",
            "ассоциация",
            "инкапсуляция",
            "наследование"
        ],
        "correctAnswers": [
            "агрегация",
            "ассоциация",
            "наследование"
        ]
    },
    {
        "question": "Отметьте целочисленные литералы языка Java:",
        "choices": [
            "15L",
            "15D",
            "0xdec",
            "3.14",
            "0x0"
        ],
        "correctAnswers": [
            "15L",
            "0xdec",
            "0x0"
        ]
    },
    {
        "question": "Какой тип должна иметь переменная d в следующем фрагменте: \nint a = 1; \nshort b = 1; \nlong c = 1; \n? d = a + b + c;",
        "choices": [
            "byte",
            "short",
            "int",
            "long",
            "char"
        ],
        "correctAnswers": [
            "long"
        ]
    },
    {
        "question": "Какие утверждения относительно импорт-выражений верны?",
        "choices": [
            "позволяют импортировать типы в модуль компиляции",
            "можно импортировать один тип",
            "нельзя импортировать пакет целиком",
            "выражение, импортирующее один тип, записывается с помощью ключевого слова import и полного имени типа"
        ],
        "correctAnswers": [
            "позволяют импортировать типы в модуль компиляции",
            "можно импортировать один тип",
            "выражение, импортирующее один тип, записывается с помощью ключевого слова import и полного имени типа"
        ]
    },
    {
        "question": "Можно ли при наследовании не реализовывать абстрактный метод родительского класса?",
        "choices": [
            "можно в любом случае",
            "можно, если наследник имеет модификатор abstract",
            "можно, если родитель имеет модификатор final",
            "нельзя"
        ],
        "correctAnswers": [
            "можно, если наследник имеет модификатор abstract"
        ]
    },
    {
        "question": "Какой метод сгенерирует ошибку ArrayStoreException при передаче в него массива v? \npublic class Vehicle { \n public static void main(String[] args) { \n  Vehicle[] v = new Car[5]; \n  ... \n } \n public void setVehicles(Vehicle c[]) { \n  c[0] = new Vehicle(); \n } \n public void setVehicles2(Vehicle c[]) { \n  if (c[0] instanceof Vehicle) { \n   c[0] = new Vehicle(); \n  } \n } \n public void setVehicles3(Car c[]) { \n  if (c[0] instanceof Car) { \n   c[0] = new Car(); \n  } \n } \n} \nclass Car extends Vehicle{}",
        "choices": [
            "setVehicles",
            "setVehicles2",
            "setVehicles3"
        ],
        "correctAnswers": [
            "setVehicles",
            "setVehicles2"
        ]
    },
    {
        "question": "Какие меры позволяют Java обеспечивать безопасность?",
        "choices": [
            "правила работы с памятью",
            "наличие виртуальной машины-интерпретатора",
            "наличие JIT-компилятора",
            "сертификаты для приложений, загружаемых по сети"
        ],
        "correctAnswers": [
            "правила работы с памятью",
            "наличие виртуальной машины-интерпретатора",
            "сертификаты для приложений, загружаемых по сети"
        ]
    },
    {
        "question": "Есть следующая иерархия наследования:  В методе testSomеValue могут быть возбуждены исключения StringIndexOutOfBoundsException и ArrayIndexOutOfBoundsException, при этом они не обрабатываются в блокеtry – catch. Какое из перечисленных ниже утверждений будет верным?",
        "choices": [
            "определение метода testSomеValue должно включатьthrows StringIndexOutOfBoundsException, ArrayIndexOutOfBoundsException",
            "если метод, вызывающий testSomeValue, перехватывает IndexOutOfBoundsException, то исключения StringIndexOutOfBoundsException, ArrayIndexOutOfBoundsException тоже будут перехватываться",
            "так как в определении метода указано throws StringIndexOutOfBoundsException, ArrayIndexOutOfBoundsException, любой вызывающий его метод должен перехватывать эти типы исключений, вне зависимости от того, возбуждается во время работы исключение или нет",
            "при объявлении метода testSomeValue необходимо указывать возбуждаемые исключения"
        ],
        "correctAnswers": [
            "если метод, вызывающий testSomeValue, перехватывает IndexOutOfBoundsException, то исключения StringIndexOutOfBoundsException, ArrayIndexOutOfBoundsException тоже будут перехватываться"
        ]
    },
    {
        "question": "Каким будет результат работы следующего кода? \npublic abstract class SomeClass implements Runnable{ \n private Object lock = new Object(); \n public void lock() { \n  synchronized (lock) { \n   try { \n    lock.wait(); \n    System.out.print(\"1\"); \n   } catch (InterruptedException e) {} \n  } \n } \n public void notifyThread() { \n  synchronized (lock) { \n   lock.notify(); \n  } \n } \n public void unlock() { \n  synchronized (lock) { \n   lock.notify(); \n   System.out.print(\"2\"); \n  } \n } \n public static void main(String s[]) { \n  SomeClass c = new SomeClass() { \n   public void run() { \n    lock(); \n   } \n  }; \n  SomeClass c1 = new SomeClass() { \n   public void run() { \n    unlock(); \n   } \n  }; \n  new Thread(c).start(); \n  new Thread(c1).start(); \n  c.notifyThread(); \n } \n}",
        "choices": [
            "программа не завершит работу, на консоли ничего не появится",
            "программа завершит работу, на консоли появится 12",
            "программа завершит работу, на консоли появится 21",
            "программа не завершит работу, на консоли появится 1",
            "результат трудно предугадать"
        ],
        "correctAnswers": [
            "результат трудно предугадать"
        ]
    },
    {
        "question": "Выберите технологии программирования:",
        "choices": [
            "структурное программирование",
            "интеграционное моделирование",
            "информационное моделирование",
            "объектно-ориентированное программирование"
        ],
        "correctAnswers": [
            "структурное программирование",
            "объектно-ориентированное программирование"
        ]
    },
    {
        "question": "Структурное программирование основано на …",
        "choices": [
            "системном проектировании функций обработки данных и детальном конструировании процедур обработки данных",
            "модульной структуре программного продукта и типовых управляющих структурах (линейной, разветвляющейся, циклической)",
            "алгоритмов обработки данных различных модулей",
            "системном проектировании функций обработки данных и детальном конструировании процедур обработки данных"
        ],
        "correctAnswers": [
            "модульной структуре программного продукта и типовых управляющих структурах (линейной, разветвляющейся, циклической)"
        ]
    },
    {
        "question": "Выберите основные управляющие структуры структурного программирования:",
        "image": "",
        "choices": [
            "процедура",
            "линия",
            "ветвление",
            "перекресток",
            "цикл",
            "безусловный переход"
        ],
        "correctAnswers": [
            "линия",
            "цикл"
        ]
    },
    {
        "question": "Структурный подход к программированию – это:",
        "choices": [
            "Совокупность рекомендуемых технологических приемов, охватывающих выполнениевсех этапов разработки программного обеспечения",
            "Создание программного обеспечения на основе структурной схемы решаемой задачи",
            "Подход, требующий разработки структурной схемы алгоритма и программы решениязадачи"
        ],
        "correctAnswers": [
            "Совокупность рекомендуемых технологических приемов, охватывающих выполнениевсех этапов разработки программного обеспечения"
        ]
    },
    {
        "question": "Что такое структурное программирование?",
        "choices": [
            "Технология разработки программного обеспечения, основой которой служит представление программы в виде математических формул и символов естественного языка",
            "Технология разработки программного обеспечения, основой которой служит представление программы в виде иерархической конструкции логических целостных фрагментов",
            "Технология разработки программного обеспечения, основой которой служит представление программы в виде логарифмических уравнений"
        ],
        "correctAnswers": [
            "Технология разработки программного обеспечения, основой которой служит представление программы в виде иерархической конструкции логических целостных фрагментов"
        ]
    },
    {
        "question": ". Как называется алгоритм, который целиком используется в составе другого алгоритма?",
        "choices": [
            "циклический",
            "служебный",
            "вспомогательный"
        ],
        "correctAnswers": [
            "вспомогательный"
        ]
    },
    {
        "question": "Что называется функцией?",
        "choices": [
            "Подпрограмма, которая имеет произвольное количество входных и выходных данных",
            "Подпрограмма, которая имеет единственный результат, записываемый в ячейку памяти, имя которой совпадает с именем подпрограммы",
            "Подпрограмма, которая небольшое количество входных и выходных данных, записываемое в ячейку памяти, имя которой не совпадает с именем подпрограммы"
        ],
        "correctAnswers": [
            "Подпрограмма, которая небольшое количество входных и выходных данных, записываемое в ячейку памяти, имя которой не совпадает с именем подпрограммы"
        ]
    },
    {
        "question": "Какое утверждение относительно класса java.lang.Object верно:",
        "choices": [
            "у этого класса нет полей",
            "нельзя явно переопределять методы этого класса",
            "нельзя явно наследовать этот класс"
        ],
        "correctAnswers": [
            "у этого класса нет полей"
        ]
    },
    {
        "question": "Какое утверждение относительно класса java.lang.Object верно:",
        "choices": [
            "нельзя явно переопределять методы этого класса",
            "у этого класса нет суперкласса",
            "нельзя явно наследовать этот класс"
        ],
        "correctAnswers": [
            "у этого класса нет суперкласса"
        ]
    },
    {
        "question": "Какое утверждение относительно модуля компиляции верно:",
        "choices": [
            "в модуле компиляции может быть больше одного объявления пакета",
            "объявления верхнего уровня позволяют обращаться к типам из других пакетов по их простым именам",
            "если объявление пакета отсутствует, то модуль компиляции будет принадлежать безымянному пакету"
        ],
        "correctAnswers": [
            "если объявление пакета отсутствует, то модуль компиляции будет принадлежать безымянному пакету"
        ]
    },
    {
        "question": "Какое утверждение относительно модуля компиляции верно:",
        "choices": [
            "import-выражения необязательны",
            "в модуле компиляции может быть больше одного объявления пакета",
            "хранится в текстовом .class-файле"
        ],
        "correctAnswers": [
            "import-выражения необязательны"
        ]
    },
    {
        "question": "Какое утверждение относительно java.util.Random корректно:",
        "choices": [
            "void nextBytes(byte[] arr) — заполняет массив arr нулями",
            "последовательный запуск приложения, генерирующего последовательность псевдослучайных чисел, никогда не вернет одинаковых последовательностей",
            "используется для получения последовательности псевдослучайных чисел"
        ],
        "correctAnswers": [
            "используется для получения последовательности псевдослучайных чисел"
        ]
    },
    {
        "question": "Какое утверждение относительно java.util.Random корректно:",
        "choices": [
            "double nextGaussian()— возвращает случайное число в диапазоне от 0.0 до 1.0 распределенное по нормальному закону",
            "void nextBytes(byte[] arr) — заполняет массив arr нулями",
            "последовательный запуск приложения, генерирующего последовательность псевдослучайных чисел, никогда не вернет одинаковых последовательностей"
        ],
        "correctAnswers": [
            "double nextGaussian()— возвращает случайное число в диапазоне от 0.0 до 1.0 распределенное по нормальному закону"
        ]
    },
    {
        "question": "Одно из ключевых слов языка Java:",
        "choices": [
            "false",
            "null",
            "default"
        ],
        "correctAnswers": [
            "default"
        ]
    },
    {
        "question": "Одно из ключевых слов языка Java:",
        "choices": [
            "null",
            "protected",
            "false"
        ],
        "correctAnswers": [
            "protected"
        ]
    },
    {
        "question": "Сколько объектов порождается при инициализации массива new int[3][]:",
        "choices": [
            "1",
            "3",
            "2"
        ],
        "correctAnswers": [
            "1"
        ]
    },
    {
        "question": "Какое утверждение относительно класса String верно:",
        "choices": [
            "является абстрактным",
            "содержит только статические методы",
            "обладает свойством неизменяемости"
        ],
        "correctAnswers": [
            "обладает свойством неизменяемости"
        ]
    },
    {
        "question": "Какое значение может принимать переменная булева типа:",
        "choices": [
            "true",
            "0",
            "1"
        ],
        "correctAnswers": [
            "true"
        ]
    },
    {
        "question": "Какое значение может принимать переменная булева типа:",
        "choices": [
            "null",
            "false",
            "1"
        ],
        "correctAnswers": [
            "false"
        ]
    },
    {
        "question": "Отметьте верное утверждение относительно языков Java и JavaScript:",
        "choices": [
            "JavaScript является синонимом Java",
            "их спецификации являются закрытыми",
            "оба языка кроссплатформенны"
        ],
        "correctAnswers": [
            "оба языка кроссплатформенны"
        ]
    },
    {
        "question": "Вы создали класс Animal в пакете ru.animal. Где будет хранится исходный код класса в файловой системе",
        "choices": [
            "ru\\animal\\Animal.class",
            "ru\\Animal.java",
            "ru\\animal\\Animal.java"
        ],
        "correctAnswers": [
            "ru\\animal\\Animal.java"
        ]
    },
    {
        "question": "Может ли массив основываться на абстрактных классах? Интерфейсах:",
        "choices": [
            "да, нет",
            "да, да",
            "нет, да"
        ],
        "correctAnswers": [
            "да, да"
        ]
    },
    {
        "question": "Что такое приоритет потока:",
        "choices": [
            "качественная характеристика, обеспечивающая распределение процессорного времени между потоками: чем выше приоритет, тем в среднем чаще будет выделяться процессорное время для такого потока",
            "процессор сначала выполняет все задачи с более высоким приоритетом, затем – с менее высоким",
            "порядковый номер потока в очереди на исполнение"
        ],
        "correctAnswers": [
            "качественная характеристика, обеспечивающая распределение процессорного времени между потоками: чем выше приоритет, тем в среднем чаще будет выделяться процессорное время для такого потока"
        ]
    },
    {
        "question": "Какое преимущество предоставляет интерфейс Runnable по сравнению с классом Thread:",
        "choices": [
            "позволяет более гибко работать с приоритетами потоков",
            "позволяет классу, содержащему логику работы, наследоваться от других классов",
            "позволяет обойтись без класса Thread"
        ],
        "correctAnswers": [
            "позволяет классу, содержащему логику работы, наследоваться от других классов"
        ]
    },
    {
        "question": "Какая кодировка используется классом OutputStreamWriter по умолчанию:",
        "choices": [
            "UTF-8 независимо от системы, где запущена Java-машина",
            "UTF-16 независимо от системы, где запущена Java-машина",
            "используемая кодировка зависит от системы, где запущена Java-машина"
        ],
        "correctAnswers": [
            "используемая кодировка зависит от системы, где запущена Java-машина"
        ]
    },
    {
        "question": "Какое утверждение относительно методов класса верно:",
        "choices": [
            "к методу, объявленному с модификаторами public final, нельзя обратиться из класса-наследника",
            "метод, объявленный с модификатором native, должен быть написан на другом языке программирования",
            "методы не могут иметь модификатор доступа default"
        ],
        "correctAnswers": [
            "метод, объявленный с модификатором native, должен быть написан на другом языке программирования"
        ]
    },
    {
        "question": "Какое утверждение относительно методов класса верно:",
        "choices": [
            "идентификатор метода при объявлении становится составным именем метода",
            "к методу, объявленному с модификаторами public final, нельзя обратиться из класса-наследника",
            "метод, объявленный с модификатором final, не может быть переопределен в классе-наследнике"
        ],
        "correctAnswers": [
            "метод, объявленный с модификатором final, не может быть переопределен в классе-наследнике"
        ]
    },
    {
        "question": "Каким образом на однопроцессорной машине исполняются многопоточные приложения",
        "choices": [
            "количество процессоров для многопоточной архитектуры не имеет значения",
            "рабочее время процессора разбивается на небольшие интервалы, в течение которых выполняется одна задача, после чего происходит переключение на следующую задачу",
            "на однопроцессорном компьютере многопоточные приложения не исполняются"
        ],
        "correctAnswers": [
            "рабочее время процессора разбивается на небольшие интервалы, в течение которых выполняется одна задача, после чего происходит переключение на следующую задачу"
        ]
    },
    {
        "question": "Какой из перечисленных ниже классов имеет наибольшее сходство с классомVector:",
        "choices": [
            "ArrayList",
            "LinkedList",
            "AbstractCollection"
        ],
        "correctAnswers": [
            "ArrayList"
        ]
    },
    {
        "question": "Какой класс соответствует классу CharArrayReader, но работает только с байтовыми данными:",
        "choices": [
            "FilterInputStream",
            "BufferedInputStream",
            "ByteArrayInputStream"
        ],
        "correctAnswers": [
            "ByteArrayInputStream"
        ]
    },
    {
        "question": "Какой метод нужно переопределить, чтобы реализовать отрисовку внешнего вида компонента:",
        "choices": [
            "paint",
            "repaint",
            "show"
        ],
        "correctAnswers": [
            "paint"
        ]
    },
    {
        "question": "От какого класса наследуются InputStream иOutputStream:",
        "choices": [
            "AbstractStream",
            "Object",
            "IOWriter"
        ],
        "correctAnswers": [
            "Object"
        ]
    },
    {
        "question": "Укажите допустимый синтаксис комментария",
        "choices": [
            "/* Комментарий */",
            "# Комментарий",
            "/* Комментарий",
            "// Комментарий"
        ],
        "correctAnswers": [
            "/* Комментарий */",
            "// Комментарий"
        ]
    },
    {
        "question": "Какие типы данных не существуют в Java?",
        "choices": [
            "int",
            "float",
            "string",
            "unknown",
            "Double"
        ],
        "correctAnswers": [
            "string",
            "unknown"
        ]
    },
    {
        "question": "Можно ли создать программу (приложение) на Java, не используя среду разработки (IDE)?",
        "choices": [
            "Да",
            "Нет, так как необходимо скомпилировать исходный код в байт-код"
        ],
        "correctAnswers": [
            "Да"
        ]
    },
    {
        "question": "Какое расширение имеют файлы с исходным кодом Java?",
        "choices": [
            "javac",
            "java",
            "class",
            "classpath"
        ],
        "correctAnswers": [
            "java"
        ]
    },
    {
        "question": "Может ли файл содержать более одного класса Java?",
        "choices": [
            "Да, но только если один внешний класс имеет модификатор доступа public",
            "Да, если все внешние классы будут иметь модификатор доступа private",
            "Нет"
        ],
        "correctAnswers": [
            "Да, но только если один внешний класс имеет модификатор доступа public"
        ]
    },
    {
        "question": "Какое имя переменной является синтаксически недопустимым?",
        "choices": [
            "53someVariable",
            "_someVariable",
            "some-variable",
            "somevariable",
            "someVariable",
            "Somevariable53"
        ],
        "correctAnswers": [
            "53someVariable",
            "some-variable"
        ]
    },
    {
        "question": "От какого класса наследуются все создаваемые классы в Java?",
        "choices": [
            "Классы наследуется от типа указанного после ключевого слова extends, если тип не указан, значит класс не является наследником",
            "Object",
            "Class"
        ],
        "correctAnswers": [
            "Object"
        ]
    },
    {
        "question": "Импорт какого пакета в Java происходит автоматически?",
        "choices": [
            "Все пакеты нужно явно указывать",
            "java.util",
            "java.lang",
            "java.text"
        ],
        "correctAnswers": [
            "java.lang"
        ]
    },
    {
        "question": "Укажите какой тип данных, из представленных, занимает наибольшее место в памяти.",
        "choices": [
            "int",
            "byte",
            "double",
            "float"
        ],
        "correctAnswers": [
            "double"
        ]
    },
    {
        "question": "Какой арифметический оператор в Java не существует?",
        "choices": [
            "--",
            "%",
            "**",
            "++"
        ],
        "correctAnswers": [
            "**"
        ]
    },
    {
        "question": "Какого оператора сравнения в Java не существует",
        "choices": [
            "!=",
            "==",
            "<>",
            "===",
            ">="
        ],
        "correctAnswers": [
            "<>",
            "==="
        ]
    },
    {
        "question": "Какой тип преобразования не произойдёт автоматически?",
        "choices": [
            "byte в short",
            "int в long",
            "char в short",
            "long в float"
        ],
        "correctAnswers": [
            "char в short"
        ]
    },
    {
        "question": "Какой тип данных не поддерживает оператор switch?",
        "choices": [
            "int",
            "String",
            "char",
            "long"
        ],
        "correctAnswers": [
            "long"
        ]
    },
    {
        "question": "Какое выражение создания переменной и массива является синтаксически некорректным?",
        "choices": [
            "int array[] = new int[0];",
            "int[] array = new int[1];",
            "int array = new int[1];",
            "int[] array = new int[] {1, 2};",
            "int[] array = {1, 2};"
        ],
        "correctAnswers": [
            "int array = new int[1];"
        ]
    },
    {
        "question": "Выбирите верное утверждение. Добавление ключевого слова final к полю класса означает, что",
        "choices": [
            "поле класса может быть инициализировано только один раз",
            "поле должно инициализироваться при объявлении, в конструкторе или в инициализаторе экземпляра",
            "поле по умолчанию становится закрытым (аналогично использованию модификатора доступа private)"
        ],
        "correctAnswers": [
            "поле класса может быть инициализировано только один раз",
            "поле должно инициализироваться при объявлении, в конструкторе или в инициализаторе экземпляра"
        ]
    },
    {
        "question": "Что не влияет на перегрузку метода?",
        "choices": [
            "Количество параметров",
            "Тип возвращаемого значения",
            "Модификаторы доступа",
            "Типы параметров"
        ],
        "correctAnswers": [
            "Тип возвращаемого значения",
            "Модификаторы доступа"
        ]
    },
    {
        "question": "Значение ключевого слова void?",
        "choices": [
            "Метод не может переопределяться в классе наследнике",
            "Метод ничего не возвращает",
            "Метод не может перегружаться"
        ],
        "correctAnswers": [
            "Метод ничего не возвращает"
        ]
    },
    {
        "question": "Назначение ключевого слова extends?",
        "choices": [
            "Используется, чтобы указать класс, интерфейс, от которого происходит наследование",
            "Добавляется к методу класса, указывая, что метод может наследоваться",
            "Используется в обобщениях (generics) для наложение ограничений типа"
        ],
        "correctAnswers": [
            "Используется, чтобы указать класс, интерфейс, от которого происходит наследование",
            "Используется в обобщениях (generics) для наложение ограничений типа"
        ]
    },
    {
        "question": "Какое ключевое слово не относится к модификаторам доступа?",
        "choices": [
            "public",
            "package",
            "private",
            "protected"
        ],
        "correctAnswers": [
            "package"
        ]
    },
    {
        "question": "Как вызвать конструктор класса? class SomeClass { }",
        "choices": [
            "construct()",
            "constructor()",
            "SomeClass()",
            "someClass()"
        ],
        "correctAnswers": [
            "SomeClass()"
        ]
    },
    {
        "question": "Все методы интерфейса по умолчанию являются",
        "choices": [
            "public и abstract",
            "protected и abstract",
            "public и super"
        ],
        "correctAnswers": [
            "public и abstract"
        ]
    },
    {
        "question": "Какие типы не относятся к примитивным?",
        "choices": [
            "int",
            "Byte",
            "char",
            "short",
            "Object",
            "String"
        ],
        "correctAnswers": [
            "Byte",
            "Object",
            "String"
        ]
    },
    {
        "question": "Выбирите только целочисленные типы.",
        "choices": [
            "int",
            "String",
            "double",
            "char",
            "short",
            "long"
        ],
        "correctAnswers": [
            "int",
            "short",
            "long"
        ]
    },
    {
        "question": "Можно ли создать свой примитивный тип данных?",
        "choices": [
            "Нет",
            "Да"
        ],
        "correctAnswers": [
            "Нет"
        ]
    },
    {
        "question": "Укажите отличия переменных примитивных и ссылочных типов.",
        "choices": [
            "Переменные примитивных типов не могут являться полями в классах, в отличии от ссылочных",
            "Переменные примитивных типов хранят значение, а переменные ссылочных типов ссылку на объект",
            "Значение переменных примитивных типов нельзя вернуть из метода, а ссылочных можно"
        ],
        "correctAnswers": [
            "Переменные примитивных типов хранят значение, а переменные ссылочных типов ссылку на объект"
        ]
    },
    {
        "question": "Какое значение по умолчанию будет присвоено для поля counter? public class Some { private Short counter; }",
        "choices": [
            "0",
            "undefined",
            "null",
            "Произойдет ошибка компиляции, так как private поля нужно обязательно инициализировать"
        ],
        "correctAnswers": [
            "null"
        ]
    },
    {
        "question": "Что будет выведено в результате выполнения кода? public class Main { public static void main(String[] args) { Some some1 = new Some(); Some some2 = some1; System.out.println(some1 == some1); } }",
        "choices": [
            "false",
            "true"
        ],
        "correctAnswers": [
            "true"
        ]
    },
    {
        "question": "Что будет выведно, в результате выполнения кода? public class Main { public static void main(String[] args) { int a = 10; int b = 2; if ((a++ > 0) | (b++ > 0)) { b += 4; } System.out.println(b); } }",
        "choices": [
            "7",
            "6",
            "2"
        ],
        "correctAnswers": [
            "7"
        ]
    },
    {
        "question": "Какой из типов относится к беззнаковым?",
        "choices": [
            "int",
            "char",
            "long",
            "double"
        ],
        "correctAnswers": [
            "char"
        ]
    },
    {
        "question": "Сколько битов в памяти занимает тип short?",
        "choices": [
            "32",
            "8",
            "16",
            "64"
        ],
        "correctAnswers": [
            "16"
        ]
    },
    {
        "question": "Какая запись вызовет ошибку во время компиляции?",
        "choices": [
            "int a = 12;",
            "int a = 014;",
            "int a = 1_2;",
            "int a = 0b1100;",
            "Все записи корректны, ошибки не будет"
        ],
        "correctAnswers": [
            "Все записи корректны, ошибки не будет"
        ]
    },
    {
        "question": "Какое значение будет выведено, при выполнении кода? public class Main { public static void main(String[] args) { int a = 10; some(a++); } public static void some(int a) { System.out.println(a); } }",
        "choices": [
            "11",
            "12",
            "10"
        ],
        "correctAnswers": [
            "10"
        ]
    },
    {
        "question": "Какое значение будет выведено, при выполнении кода? public class Main { public static void main(String[] args) { byte a = 127; System.out.println(++a); } }",
        "choices": [
            "128",
            "-128",
            "127"
        ],
        "correctAnswers": [
            "-128"
        ]
    },
    {
        "question": "Какое значение будет выведено, при выполнении кода? public class Main { public static void main(String[] args) { int a = 1; int b = 2; System.out.println(a | b); } }",
        "choices": [
            "2",
            "false",
            "3",
            "true"
        ],
        "correctAnswers": [
            "3"
        ]
    },
    {
        "question": "Возможны ли арифметические операции с типом char?",
        "choices": [
            "Да",
            "Нет"
        ],
        "correctAnswers": [
            "Да"
        ]
    },
    {
        "question": "Что будет храниться в переменной ch в результате выполнения char ch = 'a' + 1 ?",
        "choices": [
            "a1",
            "2",
            "Произойдёт ошибка, так как к символу нельзя прибавить число",
            "b"
        ],
        "correctAnswers": [
            "b"
        ]
    },
    {
        "question": "Какая кодировка используется для хранения символа в памяти?",
        "choices": [
            "Windows-1250",
            "UTF-8",
            "UTF-16",
            "ASCII"
        ],
        "correctAnswers": [
            "UTF-16"
        ]
    },
    {
        "question": "Что будет выведено в результате выполнения кода? public class Main { public static void main(String[] args) { double a = 0.1 * 10; double b = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1; System.out.println(a == b); } }",
        "choices": [
            "true",
            "false"
        ],
        "correctAnswers": [
            "false"
        ]
    },
    {
        "question": "Что нужно сделать, если требуется хранить целочисленное число, которое не помещается в тип long?",
        "choices": [
            "Использовать класс Math",
            "Использовать класс BigInteger",
            "К сожалению java не позволяет хранить числа больших размеров, и при выборе языка это нужно учитывать. Поэтому нужно использовать другой язык программирования"
        ],
        "correctAnswers": [
            "Использовать класс BigInteger"
        ]
    },
    {
        "question": "Скомпилируется ли код? public void someFunc() { char ch = 'f'; short s = ch; }",
        "choices": [
            "Да",
            "Нет"
        ],
        "correctAnswers": [
            "Нет"
        ]
    },
    {
        "question": "Скомпилируется ли код? public void someFunc() { short s = 'f'; }",
        "choices": [
            "Да",
            "Нет"
        ],
        "correctAnswers": [
            "Да"
        ]
    },
    {
        "question": "Скомпилируется ли код? Integer a = 20;",
        "choices": [
            "Нет, так как число 20 не является объектом, и относится к примитивному типу.",
            "Да, так как произойдёт автоупаковка числа в объект типа Integer"
        ],
        "correctAnswers": [
            "Да, так как произойдёт автоупаковка числа в объект типа Integer"
        ]
    },
    {
        "question": "Скомпилируется ли код? public static void main(String[] args) { Integer a = 23; Integer b = 23; int c = a + b; }",
        "image": "",
        "choices": [
            "Нет, так как операция сложения неприминима к ссылочным типам",
            "Нет, так как результат сложения должен быть присвоен переменной ссылочного типа Integer"
        ],
        "correctAnswers": [
            "Нет, так как операция сложения неприминима к ссылочным типам"
        ]
    },
    {
        "question": "Укажите допустимый вариант преобразования числа в строку?",
        "choices": [
            "(String) 45",
            "Такое невозможно",
            "Integer.toString(45)",
            "45 + '''';"
        ],
        "correctAnswers": [
            "Integer.toString(45)",
            "45 + '''';"
        ]
    },
    {
        "question": "Укажите верный способ преобразования строки в число?",
        "choices": [
            "Integer.parseInt(''34'');",
            "(Integer) ''34'';",
            "34'' + 0"
        ],
        "correctAnswers": [
            "Integer.parseInt(''34'');"
        ]
    },
    {
        "question": "Что произойдёт, если в классе прописать String text;? public class SomeClass { String text; }",
        "choices": [
            "Создаётся объект типа String, ссылка на который будет хранится в переменной text.",
            "Создаётся переменная text типа String, под которую выделяется память",
            "Ничего не произойдёт, пока не будет создан объект с помощью ключевого слова new"
        ],
        "correctAnswers": [
            "Создаётся переменная text типа String, под которую выделяется память"
        ]
    },
    {
        "question": "Назначение оператора new?",
        "choices": [
            "Создание нового объекта",
            "Объявление новой переменной",
            "Объявление нового класса"
        ],
        "correctAnswers": [
            "Создание нового объекта"
        ]
    },
    {
        "question": "Как вызвать деструктор класса?",
        "choices": [
            "Вызвав метод finalize().",
            "Такой возможности нет.",
            "Вызвав метод destroy()."
        ],
        "correctAnswers": [
            "Такой возможности нет."
        ]
    },
    {
        "question": "Как и когда происходит вызов сборщика мусора?",
        "choices": [
            "Программист, когда считает нужным, может запустить сборщик мусора",
            "Сборщик мусора запускает JVM (Java Virtual Machine), при наличии определённых условий",
            "Сборщиком мусора управляет операционная система, и запускает, когда свободной памяти останется не более 10%.",
            "У современных компьютеров всегда достаточно памяти, и необходимости в сборщике нет. Сборщик является пережитком прошлого"
        ],
        "correctAnswers": [
            "Сборщик мусора запускает JVM (Java Virtual Machine), при наличии определённых условий"
        ]
    },
    {
        "question": "Каким образом можно изменить размер массива?",
        "choices": [
            "Размер автоматически увеличится, если явно указать индекс элемента. Например так array[3] = 4, для массива new int[2].",
            "Нужно использовать специальное свойство length, которому присвоить значение новой длины массива. Например так array.length = 3.",
            "Изменить размер нельзя"
        ],
        "correctAnswers": [
            "Изменить размер нельзя"
        ]
    },
    {
        "question": "Какое значение будет выведено? public static void main(String[] args) { int[] array = new int[10]; System.out.println(array[2]); }",
        "choices": [
            "0",
            "2",
            "1"
        ],
        "correctAnswers": [
            "0"
        ]
    },
    {
        "question": "Программа не скомпилируется, так как массив не инициализирован",
        "choices": [
            "array[1]",
            "array[0]",
            "array[]"
        ],
        "correctAnswers": [
            "array[0]"
        ]
    },
    {
        "question": "Что произойдёт, если обратиться к несуществующему элементу массива (индекс выходит за пределы длины массива), например int[5]?",
        "choices": [
            "Вернётся значение равное 0.",
            "Программа не скомпилируется",
            "Произойдёт исключение ArrayIndexOutOfBoundsException."
        ],
        "correctAnswers": [
            "Произойдёт исключение ArrayIndexOutOfBoundsException."
        ]
    },
    {
        "question": "Что обозначает понятие Varargs?",
        "choices": [
            "Означает, что одним из параметров метода является массив",
            "Означает, что метод может принимать переменное количество параметров, обозначается с помощью троеточия, например int... args.",
            "Означает, что метод принимает более двух параметров"
        ],
        "correctAnswers": [
            "Означает, что метод может принимать переменное количество параметров, обозначается с помощью троеточия, например int... args."
        ]
    },
    {
        "question": "Как правильно сравнить два массива по содержанию?",
        "choices": [
            "boolean result = (array1 == array2);",
            "boolean result = array1.equals(array2);",
            "boolean result = Arrays.equals(array1, array2);"
        ],
        "correctAnswers": [
            "boolean result = Arrays.equals(array1, array2);"
        ]
    },
    {
        "question": "Как правильно преобразовать массив в строку (вместе со всем содержанием)?",
        "choices": [
            "String str = Arrays.toString(array);",
            "String str = array.toString();",
            "System.out.println(array);"
        ],
        "correctAnswers": [
            "String str = Arrays.toString(array);"
        ]
    },
    {
        "question": "Каким может быть условное выражение в операторе if (выражение)?",
        "choices": [
            "Только выражение, возвращающее значение boolean",
            "Выражение, возвращающее boolean, int, long.",
            "Любое выражение."
        ],
        "correctAnswers": [
            "Только выражение, возвращающее значение boolean"
        ]
    },
    {
        "question": "Обязательно ли в конструкции if ... else, наличие оператора else?",
        "choices": [
            "Да",
            "Нет"
        ],
        "correctAnswers": [
            "Нет"
        ]
    },
    {
        "question": "Что будет выведено в результате выполнения кода? public static void main(String[] args) { int a = 10; System.out.println((a == 10) ? 10 : 0); }",
        "choices": [
            "0",
            "Код не скомпилируется, так как содержится синтаксическая ошибка",
            "10",
            "true"
        ],
        "correctAnswers": [
            "10"
        ]
    },
    {
        "question": "Что будет выведено в результате выполнения кода? public static void main(String[] args) { int a = 10; switch (a) { case 1: System.out.println(1); case 2: System.out.println(2); break; case 10: System.out.println(10); } }",
        "choices": [
            "1 2",
            "1 2 10",
            "10"
        ],
        "correctAnswers": [
            "10"
        ]
    },
    {
        "question": "Для чего используется ключевое слово while?",
        "choices": [
            "Указывает, что метод не возвращает значения",
            "Такого слова в Java нет",
            "Создание цикла"
        ],
        "correctAnswers": [
            "Создание цикла"
        ]
    },
    {
        "question": "Явлется ли следующая запись синтаксически корректной? for (;;) { }",
        "choices": [
            "Да",
            "Нет"
        ],
        "correctAnswers": [
            "Да"
        ]
    },
    {
        "question": "Назначение оператора continue?",
        "choices": [
            "Прерывает текущую итерацию в цикле, и передаёт управление коду, следующему после цикла",
            "Прерывает текущую итерацию в цикле, и начинает следующую",
            "Возвращает значение из метода"
        ],
        "correctAnswers": [
            "Прерывает текущую итерацию в цикле, и начинает следующую"
        ]
    },
    {
        "question": "Как вернуть из метода значение 5?",
        "choices": [
            "return 5;",
            "continue 5;",
            "break 5;"
        ],
        "correctAnswers": [
            "return 5;"
        ]
    },
    {
        "question": "Что произойдёт, если в void методе указан оператор return, без возвращаемого значения?",
        "choices": [
            "Код не скомпилируется, так как метод ничего не возвращает, и не может содержать оператор return",
            "Из метода вернётся значение null",
            "Код после return не будет выполнен, и произойдёт немедленный выход из метода"
        ],
        "correctAnswers": [
            "Код после return не будет выполнен, и произойдёт немедленный выход из метода"
        ]
    },
    {
        "question": "Скомпилируется ли код? do { } while (true)",
        "choices": [
            "Да",
            "Нет"
        ],
        "correctAnswers": [
            "Нет"
        ]
    },
    {
        "question": "Назначение ключевого слова package?",
        "choices": [
            "Используется для установления принадлежности класса пакету",
            "Используется в качестве модификатора доступа класса, поля, метода и так далее",
            "Такого ключевого слова не существует"
        ],
        "correctAnswers": [
            "Используется для установления принадлежности класса пакету"
        ]
    },
    {
        "question": "Что означает понятие \"пакет по умолчанию\"?",
        "choices": [
            "Это понятие относится к пакету java.lang, который можно явно не импортировать",
            "Означает, что перед определением класса отсутствует директива package с именем пакета, которому класс принадлежит",
            "Означает, что при отсутствии модификатора доступа к классу, методу и так далее, модификтор доступа по умолчанию является package-private"
        ],
        "correctAnswers": [
            "Означает, что перед определением класса отсутствует директива package с именем пакета, которому класс принадлежит"
        ]
    },
    {
        "question": "Назначение ключевого слова import?",
        "choices": [
            "Используется для импортирования полей и методов из класса родителя при наследовании",
            "Используется для реализации интерфейсов",
            "Используется для указания полного имени класса из другого пакета, чтобы впоследствии ссылаться на импортированные классы по их короктим именам"
        ],
        "correctAnswers": [
            "Используется для указания полного имени класса из другого пакета, чтобы впоследствии ссылаться на импортированные классы по их короктим именам"
        ]
    },
    {
        "question": "Имеется следующий код:\npublic class Overload{\n  public void method(Object o) {\n    System.out.println(\"Object\");\n  }\n  public void method(java.io.FileNotFoundException f) {\n    System.out.println(\"FileNotFoundException\");\n  }\n  public void method(java.io.IOException i) {\n    System.out.println(\"IOException\");\n  }\n  public static void main(String args[]) {\n    Overload test = new Overload();\n    test.method(null);\n  }\n}\n\nРезультатом его компиляции и выполнения будет:",
        "choices": [
            "Ошибка компиляции",
            "Ошибка времени выполнения",
            "«Object»",
            "«FileNotFoundException»",
            "«IOException»"
        ],
        "correctAnswers": [
            "«FileNotFoundException»"
        ]
    },
    {
        "question": "Float f1 = new Float(Float.NaN);\nFloat f2 = new Float(Float.NaN);\nSystem.out.println( \"\"+ (f1 == f2)+\" \"+f1.equals(f2)+ \" \"+(Float.NaN == Float.NaN) );\n\nЧто будет выведено в результате выполнения данного куска кода:",
        "choices": [
            "1.\tfalse false false",
            "1.\tfalse true false",
            "1.\ttrue true false",
            "1.\tfalse true true",
            "1.\ttrue true true"
        ],
        "correctAnswers": [
            "1.\tfalse true false"
        ]
    },
    {
        "question": "class Mountain {\n  static String name = \"Himalaya\";\n  static Mountain getMountain() {\n    System.out.println(\"Getting Name \");\n    return null;\n  }\n  public static void main(String[ ] args) {\n    System.out.println( getMountain().name );\n  }\n}\n\nЧто произойдет при попытке выполнения данного кода:",
        "image": "",
        "choices": [
            "Будет выведено «Himalaya» но НЕ будет выведено «Getting Name „",
            "Будет выведено “Getting Name » и «Himalaya»",
            "Ничего не будет выведено",
            "Будет выброшен NullPointerException",
            "Будет выведено «Getting Name », а потом выброшено NullPointerException"
        ],
        "correctAnswers": [
            "Будет выведено “Getting Name » и «Himalaya»"
        ]
    },
    {
        "question": "Integer a = 120;\nInteger b = 120;\nInteger c = 130;\nInteger d = 130;\nSystem.out.println(a==b);\nSystem.out.println(c==d);\n\nВ результате выполнения данного кода будет выведено:",
        "choices": [
            "true true",
            "false false",
            "false true",
            "true false",
            "произойдет ошибка времени выполнения"
        ],
        "correctAnswers": [
            "true false"
        ]
    },
    {
        "question": "Прошлый вопрос уже когда-то поднимался на хабре, поэтому этот вопрос для тех, кому был не интересен предыдущий:\n//In File Other.java\npackage other;\npublic class Other { public static String hello = \"Hello\"; }\n\n//In File Test.java\npackage testPackage;\nimport other.*;\nclass Test{\n  public static void main(String[] args) {\n    String hello = \"Hello\", lo = \"lo\";\n    System.out.print((testPackage.Other.hello == hello) + \" \");\n    System.out.print((other.Other.hello == hello) + \" \");\n    System.out.print((hello == (\"Hel\"+\"lo\")) + \" \");\n    System.out.print((hello == (\"Hel\"+lo)) + \" \");\n    System.out.println(hello == (\"Hel\"+\"lo\").intern());\n  }\n}\nclass Other { static String hello = \"Hello\"; }\n\nВ результате мы получим:",
        "choices": [
            "false true true false true",
            "false false true false true",
            "true true true true true",
            "true true true false true",
            "Все ответы неверны"
        ],
        "correctAnswers": [
            "true true true false true"
        ]
    },
    {
        "question": "Дана сигнатура метода:\npublic static <E extends CharSequence> List<? super E> doIt(List<E> nums)\nКоторый вызывается как-то так:\nresult = doIt(in);\n\nКакого типа должны быть result и in?",
        "choices": [
            "ArrayList< String> in; List< CharSequence> result;",
            "List< String> in; List< Object> result",
            "ArrayList< String> in; List result;",
            "List< CharSequence> in; List< CharSequence> result;",
            "ArrayList< Object> in; List< CharSequence> result;"
        ],
        "correctAnswers": [
            "List< String> in; List< Object> result"
        ]
    },
    {
        "question": "public static void doIt(String String) { //1\n  int i = 10;\n  i : for (int k = 0 ; k< 10; k++) { //2\n    System.out.println( String + i); //3\n    if( k*k > 10) continue i; //4\n  }\n}\n\nДанный код:",
        "choices": [
            "Не скомпилируется из-за строки 1",
            "Не скомпилируется из-за строки 2",
            "Не скомпилируется из-за строки 3",
            "Не скомпилируется из-за строки 4",
            "Скомпилируется и запустится без проблем"
        ],
        "correctAnswers": [
            "Скомпилируется и запустится без проблем"
        ]
    },
    {
        "question": "public class Main {\n  static void method(int... a) {\n    System.out.println(\"inside int...\");\n  }\n  static void method(long a, long b) {\n    System.out.println(\"inside long\");\n  }\n  static void method(Integer a, Integer b) {\n    System.out.println(\"inside INTEGER\");\n  }\n  public static void main(String[] args) {\n    int a = 2;\n    int b = 3;\n    method(a,b);\n  }\n}\n\nВ результате мы получим:",
        "choices": [
            "Ошибку компиляции",
            "Ошибку времени выполнения",
            "«inside int...»",
            "«inside long»",
            "«inside INTEGER»"
        ],
        "correctAnswers": [
            "«inside long»"
        ]
    },
    {
        "question": "class Super { static String ID = \"QBANK\"; }\nclass Sub extends Super{\n  static { System.out.print(\"In Sub\"); }\n}\nclass Test{\n  public static void main(String[] args) {\n    System.out.println(Sub.ID);\n  }\n}\n\nВ результате выполнения данного кода:",
        "choices": [
            "Он даже не скомпилируется",
            "Результат зависит от реализации JVM",
            "Будет выведено «QBANK»",
            "Будет выведено «In Sub» и «QBANK»",
            "Все ответы неверны"
        ],
        "correctAnswers": [
            "Будет выведено «QBANK»"
        ]
    },
    {
        "question": "Имеется два класса:\n//in file A.java\npackage p1;\npublic class A{\n  protected int i = 10;\n  public int getI() { return i; }\n}\n\n//in file B.java\npackage p2;\nimport p1.*;\npublic class B extends A{\n  public void process(A a) {\n    a.i = a.i*2;\n  }\n  public static void main(String[] args) {\n    A a = new B();\n    B b = new B();\n    b.process(a);\n    System.out.println( a.getI() );\n  }\n}\n\nВ результате выполнения класса В мы получим:",
        "choices": [
            "Будет выведено «20»",
            "Будет выведено «10»",
            "Код не скомпилирутся",
            "возникнет ошибка времени выполнения",
            "Все ответы неверны"
        ],
        "correctAnswers": [
            "Код не скомпилирутся"
        ]
    },
    {
        "question": "Какие утверждения относительно класса java.lang.Object верны ",
        "choices": [
            "нельзя явно наследовать этот класс",
            "нельзя явно переопределять методы этого класса",
            "у этого класса нет полей",
            "у этого класса нет суперкласса",
            "любой класс напрямую, или через своих родителей, является наследником Object"
        ],
        "correctAnswers": [
            "у этого класса нет полей",
            "у этого класса нет суперкласса",
            "любой класс напрямую, или через своих родителей, является наследником Object"
        ]
    },
    {
        "question": "Какие утверждения относительно модуля компиляции верны? ",
        "choices": [
            "в модуле компиляции может быть больше одного объявления пакета",
            "если объявление пакета отсутствует, то модуль компиляции будет принадлежать безымянному пакету",
            "объявления верхнего уровня позволяют обращаться к типам из других пакетов по их простым именам",
            "хранится в текстовом .class-файле",
            "import-выражения необязательны"
        ],
        "correctAnswers": [
            "если объявление пакета отсутствует, то модуль компиляции будет принадлежать безымянному пакету",
            "import-выражения необязательны"
        ]
    },
    {
        "question": "Какие из следующих адресов относятся к подсети класса B? ",
        "choices": [
            "194.80.20.1",
            "224.0.0.10",
            "172.16.0.1",
            "140.150.160.1"
        ],
        "correctAnswers": [
            "172.16.0.1",
            "140.150.160.1"
        ]
    },
    {
        "question": "какие варианты кода не вызовут ошибку компиляции? ",
        "choices": [
            "class Parent {} interface FirstChild {} interface SecondChild implements FirstChild {}",
            "class Parent {} interface FirstChild {} interface SecondChild extends FirstChild {}",
            "class Parent {} interface FirstChild {} class SecondChild implements FirstChild {}",
            "class Parent {} interface FirstChild extends Parent {} class SecondChild implements FirstChild {}",
            "class Parent {} class FirstChild extends Parent {} class SecondChild implements FirstChild {}"
        ],
        "correctAnswers": [
            "class Parent {} interface FirstChild {} interface SecondChild extends FirstChild {}",
            "class Parent {} interface FirstChild {} class SecondChild implements FirstChild {}"
        ]
    },
    {
        "question": "Какие утверждения относительно java.util.ResourceBundle корректны? ",
        "choices": [
            "позволяет манипулировать наборами ресурсов, зависящих от локалей",
            "загрузка объекта для нужной локали производится с помощью статического метода getResource()",
            "класс ресурсов может иметь модификатор protected",
            "предназначен для хранения объектов, общих для всех локалей",
            "класс ресурсов может иметь модификатор private"
        ],
        "correctAnswers": [
            "позволяет манипулировать наборами ресурсов, зависящих от локалей",
            "класс ресурсов может иметь модификатор protected"
        ]
    },
    {
        "question": "Какой из следующих вариантов кода будет скомпилирован без ошибок ",
        "choices": [
            "public class SomeClass { int a = b; static int b = 5; }",
            "public class SomeClass { int a = SomeClass.b; static int b = 5; }",
            "public class SomeClass { static int a = SomeClass.b; static int b = 5; }",
            "public class SomeClass { static int a = b; static int b = 5; }",
            "public class SomeClass { static int a = SomeClass.b; static int SomeClass.b = 5; }"
        ],
        "correctAnswers": [
            "public class SomeClass { int a = b; static int b = 5; }",
            "public class SomeClass { int a = SomeClass.b; static int b = 5; }",
            "public class SomeClass { static int a = SomeClass.b; static int b = 5; }"
        ]
    },
    {
        "question": "Для каких элементов в Java можно указать модификатор доступа? ",
        "choices": [
            "для конструкторов класса",
            "для типов (классов и интерфейсов) объявления верхнего уровня",
            "для элементов ссылочных типов для пакетов"
        ],
        "correctAnswers": [
            "для конструкторов класса",
            "для типов (классов и интерфейсов) объявления верхнего уровня",
            "для элементов ссылочных типов для пакетов"
        ]
    },
    {
        "question": "Какие утверждения относительно java.util.Random корректны? ",
        "choices": [
            "последовательный запуск приложения, генерирующего последовательность псевдослучайных чисел, никогда не вернет одинаковых последовательностей",
            "void nextBytes(byte[] arr) — заполняет массив arr нулями",
            "используется для получения последовательности псевдослучайных чисел",
            "double nextGaussian()— возвращает случайное число в диапазоне от 0.0 до 1.0 распределенное по нормальному закону"
        ],
        "correctAnswers": [
            "используется для получения последовательности псевдослучайных чисел",
            "double nextGaussian()— возвращает случайное число в диапазоне от 0.0 до 1.0 распределенное по нормальному закону"
        ]
    },
    {
        "question": "Отметьте ключевые слова языка Java: ",
        "choices": [
            "boolean",
            "null",
            "false",
            "default",
            "protected"
        ],
        "correctAnswers": [
            "boolean",
            "default",
            "protected"
        ]
    },
    {
        "question": "Какие из следующих присвоений корректны? ",
        "choices": [
            "char c = (byte)5 + ‘a’",
            "System.out.println(«»perform»»); } private SomeClass c; public static\nvoid main(String[] args) { SomeClass.perform(); } } public class",
            "byte b2 = 200",
            "byte c = (char)5 + ‘a’;",
            "short s = (short)(2 + 3);"
        ],
        "correctAnswers": [
            "char c = (byte)5 + ‘a’",
            "byte c = (char)5 + ‘a’;",
            "short s = (short)(2 + 3);"
        ]
    },
    {
        "question": "Сколько объектов порождается при инициализации массива new int[3][]?",
        "choices": [
            "ни одного, так как код не будет скомпилирован",
            "4",
            "2",
            "3",
            "1"
        ],
        "correctAnswers": [
            "1"
        ]
    },
    {
        "question": "Что будет выведено в результате выполнения кода?\n```java\npublic static void main(String[] args) {\n    int a = 10;\n    switch (a) {\n        case 1:\n            System.out.println(1);\n        case 2:\n            System.out.println(2);\n            break;\n        case 10:\n            System.out.println(10);\n    }\n}\n```",
        "choices": [
            "1 2",
            "1 2 10",
            "10"
        ],
        "correctAnswers": [
            "10"
        ]
    },
    {
        "question": "Для чего используется ключевое слово while?",
        "choices": [
            "Указывает, что метод не возвращает значения",
            "Такого слова в Java нет",
            "Создание цикла."
        ],
        "correctAnswers": [
            "Создание цикла."
        ]
    },
    {
        "question": "Явлется ли следующая запись синтаксически корректной?\n```java\nfor (;;) { }\n```",
        "choices": [
            "Да",
            "Нет"
        ],
        "correctAnswers": [
            "Да"
        ]
    },
    {
        "question": "Назначение оператора continue?",
        "choices": [
            "Прерывает текущую итерацию в цикле, и передаёт управление коду, следующему после цикла",
            "Прерывает текущую итерацию в цикле, и начинает следующую",
            "Возвращает значение из метода"
        ],
        "correctAnswers": [
            "Прерывает текущую итерацию в цикле, и начинает следующую"
        ]
    },
    {
        "question": "Как вернуть из метода значение 5?",
        "choices": [
            "return 5;",
            "continue 5;",
            "break 5;"
        ],
        "correctAnswers": [
            "return 5;"
        ]
    },
    {
        "question": "Что произойдёт, если в void методе указан оператор return, без возвращаемого значения?",
        "choices": [
            "Код не скомпилируется, так как метод ничего не возвращает, и не может содержать оператор return.",
            "Из метода вернётся значение null",
            "Код после return не будет выполнен, и произойдёт немедленный выход из метода"
        ],
        "correctAnswers": [
            "Код после return не будет выполнен, и произойдёт немедленный выход из метода"
        ]
    },
    {
        "question": "Скомпилируется ли код?\n```java\ndo { } while (true)\n```",
        "choices": [
            "Да",
            "Нет"
        ],
        "correctAnswers": [
            "Нет"
        ]
    },
    {
        "question": "Назначение ключевого слова package?",
        "choices": [
            "Используется для установления принадлежности класса пакету",
            "Используется в качестве модификатора доступа класса, поля, метода и так далее",
            "Такого ключевого слова не существует"
        ],
        "correctAnswers": [
            "Используется для установления принадлежности класса пакету"
        ]
    },
    {
        "question": "Что означает понятие \"пакет по умолчанию\"?",
        "choices": [
            "Это понятие относится к пакету java.lang, который можно явно не импортировать",
            "Означает, что перед определением класса отсутствует директива package с именем пакета, которому класс принадлежит",
            "Означает, что при отсутствии модификатора доступа к классу, методу и так далее, модификатор доступа по умолчанию является package-private"
        ],
        "correctAnswers": [
            "Означает, что перед определением класса отсутствует директива package с именем пакета, которому класс принадлежит"
        ]
    },
    {
        "question": "Назначение ключевого слова import?",
        "choices": [
            "Используется для импортирования полей и методов из класса родителя при наследовании",
            "Используется для реализации интерфейсов",
            "Используется для указания полного имени класса из другого пакета, чтобы впоследствии ссылаться на импортированные классы по их короктим именам"
        ],
        "correctAnswers": [
            "Используется для указания полного имени класса из другого пакета, чтобы впоследствии ссылаться на импортированные классы по их короктим именам"
        ]
    },
    {
        "question": "Имеется следующий код:\n```java\npublic class Overload{\n  public void method(Object o) {\n    System.out.println(\"Object\");\n  }\n  public void method(java.io.FileNotFoundException f) {\n    System.out.println(\"FileNotFoundException\");\n  }\n  public void method(java.io.IOException i) {\n    System.out.println(\"IOException\");\n  }\n  public static void main(String args[]) {\n    Overload test = new Overload();\n    test.method(null);\n  }\n}\n```\n\nРезультатом его компиляции и выполнения будет:",
        "choices": [
            "Ошибка компиляции",
            "Ошибка времени выполнения",
            "«Object»",
            "«FileNotFoundException»",
            "«IOException»"
        ],
        "correctAnswers": [
            "«FileNotFoundException»"
        ]
    },
    {
        "question": "```java\nFloat f1 = new Float(Float.NaN);\nFloat f2 = new Float(Float.NaN);\nSystem.out.println( \"\"+ (f1 == f2)+\" \"+f1.equals(f2)+ \" \"+(Float.NaN == Float.NaN) );\n```\n\nЧто будет выведено в результате выполнения данного куска кода:",
        "choices": [
            "false false false",
            "false true false",
            "true true false",
            "false true true",
            "true true true"
        ],
        "correctAnswers": [
            "false true false"
        ]
    },
    {
        "question": "Что произойдет при попытке выполнения данного кода:\n\nclass Mountain {\n  static String name = \"Himalaya\";\n  static Mountain getMountain() {\n    System.out.println(\"Getting Name \");\n    return null;\n  }\n  public static void main(String[ ] args) {\n    System.out.println( getMountain().name );\n  }\n}\n",
        "choices": [
            "Будет выведено «Himalaya» но НЕ будет выведено «Getting Name »",
            "Будет выведено «Getting Name » и «Himalaya»",
            "Ничего не будет выведено",
            "Будет выброшен NullPointerException",
            "Будет выведено «Getting Name », а потом выброшено NullPointerException"
        ],
        "correctAnswers": [
            "Будет выведено «Getting Name » и «Himalaya»"
        ]
    },
    {
        "question": "```java\nInteger a = 120;\nInteger b = 120;\nInteger c = 130;\nInteger d = 130;\nSystem.out.println(a==b);\nSystem.out.println(c==d);\n```\n\nВ результате выполнения данного кода будет выведено:",
        "choices": [
            "true true",
            "false false",
            "false true",
            "true false",
            "произойдет ошибка времени выполнения"
        ],
        "correctAnswers": [
            "true false"
        ]
    },
    {
        "question": "Прошлый вопрос уже когда-то поднимался на хабре, поэтому этот вопрос для тех, кому был не интересен предыдущий:\n```java\n//In File Other.java\npackage other;\npublic class Other { public static String hello = \"Hello\"; }\n//In File Test.java\npackage testPackage;\nimport other.*;\nclass Test{\n  public static void main(String[] args) {\n    String hello = \"Hello\", lo = \"lo\";\n    System.out.print((testPackage.Other.hello == hello) + \" \");\n    System.out.print((other.Other.hello == hello) + \" \");\n    System.out.print((hello == (\"Hel\"+\"lo\")) + \" \");\n    System.out.print((hello == (\"Hel\"+lo)) + \" \");\n    System.out.println(hello == (\"Hel\"+lo).intern());\n  }\n}\nclass Other { static String hello = \"Hello\"; }\n```\n\nВ результате мы получим:",
        "choices": [
            "false true true false true",
            "false false true false true",
            "true true true true true",
            "true true true false true",
            "Все ответы неверны"
        ],
        "correctAnswers": [
            "true true true false true"
        ]
    },
    {
        "question": "Дана сигнатура метода:\n```java\npublic static <E extends CharSequence> List<? super E> doIt(List<E> nums)\n```\nКоторый вызывается как-то так:\n```java\nresult = doIt(in);\n```\n\nКакого типа должны быть result и in?",
        "choices": [
            "ArrayList< String> in; List< CharSequence> result;",
            "List< String> in; List< Object> result;",
            "ArrayList< String> in; List result;",
            "List< CharSequence> in; List< CharSequence> result;",
            "ArrayList< Object> in; List< CharSequence> result"
        ],
        "correctAnswers": [
            "ArrayList< String> in; List result;"
        ]
    },
    {
        "question": "```java\npublic static void doIt(String String) { //1\n  int i = 10;\n  i : for (int k = 0 ; k< 10; k++) { //2\n    System.out.println( String + i); //3\n    if( k*k > 10) continue i; //4\n  }\n}\n```\n\nДанный код:",
        "choices": [
            "Не скомпилируется из-за строки 1",
            "Не скомпилируется из-за строки 2",
            "Не скомпилируется из-за строки 3",
            "Не скомпилируется из-за строки 4",
            "Скомпилируется и запустится без проблем"
        ],
        "correctAnswers": [
            "Скомпилируется и запустится без проблем"
        ]
    },
    {
        "question": "```java\npublic class Main {\n  static void method(int... a) {\n    System.out.println(\"inside int...\");\n  }\n  static void method(long a, long b) {\n    System.out.println(\"inside long\");\n  }\n  static void method(Integer a, Integer b) {\n    System.out.println(\"inside INTEGER\");\n  }\n  public static void main(String[] args) {\n    int a = 2;\n    int b = 3;\n    method(a,b);\n  }\n}\n```\n\nВ результате мы получим:",
        "choices": [
            "Ошибку компиляции",
            "Ошибку времени выполнения",
            "«inside int...»",
            "«inside long»",
            "«inside INTEGER»"
        ],
        "correctAnswers": [
            "«inside long»"
        ]
    },
    {
        "question": "```java\nclass Super { static String ID = \"QBANK\"; }\nclass Sub extends Super{\n  static { System.out.print(\"In Sub\"); }\n}\nclass Test{\n  public static void main(String[] args) {\n    System.out.println(Sub.ID);\n  }\n}\n```\n\nВ результате выполнения данного кода:",
        "choices": [
            "Он даже не скомпилируется",
            "Результат зависит от реализации JVM",
            "Будет выведено «QBANK»",
            "Будет выведено «In Sub» и «QBANK»",
            "Все ответы неверны"
        ],
        "correctAnswers": [
            "Будет выведено «QBANK»"
        ]
    },
    {
        "question": "Имеется два класса:\n```java\n//in file A.java\npackage p1;\npublic class A{\n  protected int i = 10;\n  public int getI() { return i; }\n}\n```\n\n```java\n//in file B.java\npackage p2;\nimport p1.*;\npublic class B extends A{\n  public void process(A a) {\n    a.i = a.i*2;\n  }\n  public static void main(String[] args) {\n    A a = new B();\n    B b = new B();\n    b.process(a);\n    System.out.println( a.getI() );\n  }\n}\n```\n\nВ результате выполнения класса В мы получим:",
        "choices": [
            "Будет выведено «20»",
            "Будет выведено «10»",
            "Код не скомпилирутся",
            "Возникнет ошибка времени выполнения",
            "Все ответы неверны"
        ],
        "correctAnswers": [
            "Код не скомпилирутся"
        ]
    },
    {
        "question": "Какие варианты кода не вызовут ошибку компиляции?",
        "choices": [
            "class Parent {} interface FirstChild {} interface SecondChild implements FirstChild {}",
            "class Parent {} interface FirstChild {} interface SecondChild extends FirstChild {}",
            "class Parent {} interface FirstChild {} class SecondChild implements FirstChild {}",
            "class Parent {} interface FirstChild extends Parent {} class SecondChild implements FirstChild {}",
            "class Parent {} class FirstChild extends Parent {} class SecondChild implements FirstChild {}"
        ],
        "correctAnswers": [
            "class Parent {} interface FirstChild {} interface SecondChild extends FirstChild {}",
            "class Parent {} interface FirstChild {} class SecondChild implements FirstChild {}"
        ]
    },
    {
        "question": "Какие утверждения относительно java.util.ResourceBundle корректны?",
        "choices": [
            "позволяет манипулировать наборами ресурсов, зависящих от локалей",
            "загрузка объекта для нужной локали производится с помощью статического метода getResource()",
            "класс ресурсов может иметь модификатор protected",
            "предназначен для хранения объектов, общих для всех локалей",
            "класс ресурсов может иметь модификатор private"
        ],
        "correctAnswers": [
            "позволяет манипулировать наборами ресурсов, зависящих от локалей",
            "класс ресурсов может иметь модификатор protected"
        ]
    },
    {
        "question": "Какой из следующих вариантов кода будет скомпилирован без ошибок",
        "choices": [
            "public class SomeClass { int a = b; static int b = 5; }",
            "public class SomeClass { int a = SomeClass.b; static int b = 5; }",
            "public class SomeClass { static int a = SomeClass.b; static int b = 5; }",
            "public class SomeClass { static int a = b; static int b = 5; }",
            "public class SomeClass { static int a = b; static int b = 5; }"
        ],
        "correctAnswers": [
            "public class SomeClass { int a = b; static int b = 5; }",
            "public class SomeClass { int a = SomeClass.b; static int b = 5; }",
            "public class SomeClass { static int a = SomeClass.b; static int b = 5; }"
        ]
    },
    {
        "question": "Для каких элементов в Java можно указать модификатор доступа?",
        "choices": [
            "для конструкторов класса",
            "для типов (классов и интерфейсов) объявления верхнего уровня",
            "для элементов ссылочных типов для пакетов"
        ],
        "correctAnswers": [
            "для конструкторов класса",
            "для типов (классов и интерфейсов) объявления верхнего уровня",
            "для элементов ссылочных типов для пакетов"
        ]
    },
    {
        "question": "Какие утверждения относительно java.util.Random корректны? ",
        "choices": [
            "последовательный запуск приложения, генерирующего последовательность псевдослучайных чисел, никогда не вернет одинаковых последовательностей",
            "void nextBytes(byte[] arr) — заполняет массив arr нулями",
            "используется для получения последовательности псевдослучайных чисел",
            "double nextGaussian()— возвращает случайное число в диапазоне от 0.0 до 1.0 распределенное по нормальному закону"
        ],
        "correctAnswers": [
            "используется для получения последовательности псевдослучайных чисел",
            "double nextGaussian()— возвращает случайное число в диапазоне от 0.0 до 1.0 распределенное по нормальному закону"
        ]
    },
    {
        "question": "Отметьте ключевые слова языка Java:",
        "choices": [
            "boolean",
            "null",
            "false",
            "default",
            "protected"
        ],
        "correctAnswers": [
            "boolean",
            "default",
            "protected"
        ]
    },
    {
        "question": "Какие из следующих присвоений корректны?",
        "choices": [
            "char c = (byte)5 + ‘a’;",
            "byte b2 = 200;",
            "byte c = (int)150 + ‘a’;",
            "byte c = (char)5 + ‘a’;",
            "short s = (short)(2 + 3);"
        ],
        "correctAnswers": [
            "char c = (byte)5 + ‘a’;",
            "byte c = (char)5 + ‘a’;",
            "short s = (short)(2 + 3);"
        ]
    },
    {
        "question": "Какие из следующих присвоений корректны?",
        "choices": [
            "char c = (byte)5 + ‘a’;",
            "byte b2 = 200;",
            "byte c = (int)150 + ‘a’;",
            "byte c = (char)5 + ‘a’;",
            "short s = (short)(2 + 3);"
        ],
        "correctAnswers": [
            "char c = (byte)5 + ‘a’;",
            "byte c = (char)5 + ‘a’;",
            "short s = (short)(2 + 3);"
        ]
    },
    {
        "question": "Программа не завершит работу, на консоли появится 1\nпрограмма не завершит работу, на консоли ничего не появится",
        "choices": [
            "программа не завершит работу, на консоли появится 2",
            "результат трудно предугадать"
        ],
        "correctAnswers": [
            "программа не завершит работу, на консоли появится 2"
        ]
    },
    {
        "question": "Программа не завершит работу, на консоли появится 1\nпрограмма не завершит работу, на консоли ничего не появится",
        "choices": [
            "программа не завершит работу, на консоли появится 2",
            "результат трудно предугадать"
        ],
        "correctAnswers": [
            "программа не завершит работу, на консоли появится 2"
        ]
    },
    {
        "question": "Какие утверждения относительно класса String верны?",
        "choices": [
            "содержит только статические методы",
            "является абстрактным",
            "обладает свойством неизменяемости от этого класса можно унаследоваться"
        ],
        "correctAnswers": [
            "обладает свойством неизменяемости от этого класса можно унаследоваться"
        ]
    },
    {
        "question": "Отметьте верное утверждение относительно языков Java и JavaScript:",
        "choices": [
            "оба языка кроссплатформенны JavaScript",
            "является синонимом Java",
            "их спецификации являются закрытыми"
        ],
        "correctAnswers": [
            "оба языка кроссплатформенны JavaScript"
        ]
    },
    {
        "question": "Какое из перечисленных ниже имен является составным?",
        "choices": [
            "Object java.lang lang java.lang.Object",
            "Object",
            "java.lang",
            "lang",
            "java.lang.Object"
        ],
        "correctAnswers": [
            "java.lang",
            "java.lang.Object"
        ]
    },
    {
        "question": "Может ли массив основываться на абстрактных классах? Интерфейсах?",
        "choices": [
            "да, да",
            "да, нет",
            "нет, нет",
            "нет, да"
        ],
        "correctAnswers": [
            "да, да"
        ]
    },
    {
        "question": "Один из принципов объектно-ориентированного программирования:",
        "choices": [
            "Абстракционизм",
            "Полиморфизм",
            "Монорфизм"
        ],
        "correctAnswers": [
            "Полиморфизм"
        ]
    },
    {
        "question": "Метод определения объектов, при котором производные объекты наследуют свойства от своих потом",
        "choices": [
            "Монорфизм",
            "Полиморфизм",
            "Наследование"
        ],
        "correctAnswers": [
            "Наследование"
        ]
    },
    {
        "question": "Свойство объектов, при котором действие с одинаковыми именами вызывает различное поведение для различных объектов",
        "choices": [
            "Полиморфизм",
            "Передача",
            "Монорфизм"
        ],
        "correctAnswers": [
            "Полиморфизм"
        ]
    },
    {
        "question": "Данные, характеризующие состояние объекта",
        "choices": [
            "Доли объекта",
            "Части объекта",
            "Атрибуты объекта"
        ],
        "correctAnswers": [
            "Атрибуты объекта"
        ]
    },
    {
        "question": "Совокупность объектов, характеризующаяся общностью методов и свойств:",
        "choices": [
            "Класс",
            "Вид",
            "Род"
        ],
        "correctAnswers": [
            "Класс"
        ]
    },
    {
        "question": "Изменение состояния объекта в ответ на какое-либо действие:",
        "choices": [
            "Значение",
            "Событие",
            "Данность"
        ],
        "correctAnswers": [
            "Событие"
        ]
    },
    {
        "question": "Действие, которое может выполнить объект:",
        "choices": [
            "Метод",
            "Событие",
            "Свойство"
        ],
        "correctAnswers": [
            "Метод"
        ]
    },
    {
        "question": "Характеристика объекта:",
        "choices": [
            "Событие",
            "Данность",
            "Свойство"
        ],
        "correctAnswers": [
            "Свойство"
        ]
    },
    {
        "question": "Совокупность свойств и методов:",
        "choices": [
            "Объект",
            "Свойство",
            "Событие"
        ],
        "correctAnswers": [
            "Объект"
        ]
    },
    {
        "question": "Тип, соответствующий классу:",
        "image": "",
        "choices": [
            "Объективный тип",
            "Объектный тип +",
            "Видимый тип"
        ],
        "correctAnswers": [
            "Объектный тип +"
        ]
    },
    {
        "question": "Компоненты, которые видны во время работы приложения, с ними напрямую может взаимодействовать пользователь, называются",
        "choices": [
            "Абстрактными",
            "Видимыми",
            "Визуальными"
        ],
        "correctAnswers": [
            "Визуальными"
        ]
    },
    {
        "question": "Объектно-ориентированный подход (ООП) - это:",
        "choices": [
            "подход, при котором система разбивается на функциональные подсистемы, которые в свою очередь делятся на подфункции, подразделяемые на задачи и так далее",
            "подход, при котором требования к системе воспринимаются с точки зрения классов и объектов, выявленных в предметной области",
            "процесс разработки ПО, который обеспечивает упорядоченность к распределению задач и обязанностей в организации-разработчике"
        ],
        "correctAnswers": [
            "подход, при котором система разбивается на функциональные подсистемы, которые в свою очередь делятся на подфункции, подразделяемые на задачи и так далее"
        ]
    },
    {
        "question": "К наиболее популярным методологиям, поддерживающим ООП относятся",
        "choices": [
            "Экстремальное программирование",
            "Имитационное моделирование",
            "Гибкое моделирование",
            "Унифицированный процесс"
        ],
        "correctAnswers": [
            "Экстремальное программирование"
        ]
    },
    {
        "question": "Каким образом в ООП представляется модуль?",
        "choices": [
            "в виде ориентированного графа",
            "в виде дерева",
            "в виде иерархии"
        ],
        "correctAnswers": [
            "в виде ориентированного графа"
        ]
    },
    {
        "question": "Унифицированный процесс – это",
        "choices": [
            "обобщенный шаблон, который может быть применен для разработки и сопровождения широкого круга систем",
            "процесс разработки ПО, который обеспечивает упорядоченный подход к распределению задач и обязанностей",
            "система обозначений для определения, визуализации и конструирования моделей системы в виде диаграмм и документов на основе ООП"
        ],
        "correctAnswers": [
            "процесс разработки ПО, который обеспечивает упорядоченный подход к распределению задач и обязанностей"
        ]
    },
    {
        "question": "Каким образом в ООП осуществлена организация внутри модулей?",
        "choices": [
            "модуль состоит из функций, иерархически связанных между собой отношением композиции",
            "иерархия выстраивается с использованием двух отношений: композиция и наследование",
            "«объект-часть» может включаться сразу в несколько ''объектов-целое''"
        ],
        "correctAnswers": [
            "модуль состоит из функций, иерархически связанных между собой отношением композиции"
        ]
    },
    {
        "question": "Что такое паттерны проектирования?",
        "choices": [
            "именованная пара «проблема/решение», содержащая готовое обобщенное решение типичной проблемы",
            "упорядоченный поход к распределению задач и обязанностей",
            "язык визуализации"
        ],
        "correctAnswers": [
            "именованная пара «проблема/решение», содержащая готовое обобщенное решение типичной проблемы"
        ]
    },
    {
        "question": "Какие преимущества ООП можно выделить по сравнению со структурным подходом?",
        "choices": [
            "объединение атрибутов и методов, а также инкапсуляция позволяют добиться большей внутренней и меньшей внешней связности между компонентами системы",
            "применение ООП позволяет легче организовать параллельные вычисления",
            "применение ООП существенно повышает уровень унификации разработки и пригодность для повторного использования проектов",
            "для моделирования с использованием ООП не нужно владеть определенной квалификацией и знаниями, т.к. ООП прост и понятен"
        ],
        "correctAnswers": [
            "применение ООП существенно повышает уровень унификации разработки и пригодность для повторного использования проектов"
        ]
    },
    {
        "question": "Какие подходы к определению общих свойств объектов можно выделить?",
        "choices": [
            "классический подход",
            "концептуальная кластеризация",
            "объектный подход",
            "теория прототипов",
            "архитектурный подход"
        ],
        "correctAnswers": [
            "классический подход",
            "объектный подход"
        ]
    },
    {
        "question": "При каком походе первоначальным этапом является формирование описания классов, а затем классификация сущности в соответствии с этими описаниями",
        "choices": [
            "классический подход",
            "концептуальная кластеризация",
            "объектный подход",
            "теория прототипов",
            "архитектурный подход"
        ],
        "correctAnswers": [
            "объектный подход"
        ]
    },
    {
        "question": "Какой подход можно связать с теорией нечетких множеств из-за принадлежности одного объекта к нескольким категориям одновременно?",
        "choices": [
            "классический подход",
            "концептуальная кластеризация",
            "объектный подход",
            "теория прототипов",
            "архитектурный подход"
        ],
        "correctAnswers": [
            "классический подход"
        ]
    },
    {
        "question": "При каком подходе классификация производится по степени сходства объектов с конкретным шаблоном?",
        "choices": [
            "классический подход",
            "концептуальная кластеризация",
            "объектный подход",
            "теория прототипов",
            "архитектурный подход"
        ],
        "correctAnswers": [
            "объектный подход"
        ]
    },
    {
        "question": "При каком подходе классификация осуществляется в соответствии с различными концепциями?",
        "choices": [
            "классический подход",
            "концептуальная кластеризация",
            "объектный подход",
            "теория прототипов",
            "архитектурный подход"
        ],
        "correctAnswers": [
            "концептуальная кластеризация"
        ]
    },
    {
        "question": "При каком подходе в качестве критерия похожести объектов используется родственность свойств объектов?",
        "choices": [
            "классический подход",
            "концептуальная кластеризация",
            "объектный подход",
            "теория прототипов",
            "архитектурный подход"
        ],
        "correctAnswers": [
            "теория прототипов"
        ]
    },
    {
        "question": "Какие преимущества можно выделить при применении шаблонов?",
        "choices": [
            "сокращение затрат",
            "простота применения",
            "сокращение времени на разработку ПО",
            "повышение качества разработки ПО"
        ],
        "correctAnswers": [
            "сокращение затрат",
            "сокращение времени на разработку ПО"
        ]
    },
    {
        "question": "При каком из подходов, системы получаются более компактными?",
        "choices": [
            "структурном подходе",
            "объектно-ориентированном подходе",
            "при любом подходе"
        ],
        "correctAnswers": [
            "объектно-ориентированном подходе"
        ]
    },
    {
        "question": "Какие принципы объектной модели являются обязательными?",
        "choices": [
            "сохраняемость",
            "абстрагирование",
            "инкапсуляция",
            "параллелизм",
            "модульность",
            "иерархичность"
        ],
        "correctAnswers": [
            "абстрагирование",
            "инкапсуляция",
            "параллелизм"
        ]
    },
    {
        "question": "Инвариант - это:",
        "choices": [
            "некоторое логическое условие, значение которого (истина или ложь) должно сохраняться",
            "внешнее проявление объекта с точки зрения его контракта с другими объектами",
            "свойство системы, которое было разложено на внутренне связные, но слабо связанные между собой модули"
        ],
        "correctAnswers": [
            "свойство системы, которое было разложено на внутренне связные, но слабо связанные между собой модули"
        ]
    },
    {
        "question": "Абстрагирование ...?",
        "choices": [
            "выделяет характеристики объекта, отличающие его от других объектов",
            "четко определяет концептуальные границы",
            "позволяет отделить самые существенные особенности поведения от несущественных"
        ],
        "correctAnswers": [
            "выделяет характеристики объекта, отличающие его от других объектов"
        ]
    },
    {
        "question": "На какие из перечисленных видов делится абстрагирование?",
        "choices": [
            "абстракция сущности",
            "абстракция типа",
            "абстракция виртуальной машины"
        ],
        "correctAnswers": [
            "абстракция сущности",
            "абстракция типа"
        ]
    },
    {
        "question": "Типизация - это:",
        "choices": [
            "способность объекта существовать во времени, переживая породивший его процесс, и/или в пространстве, перемещаясь из своего первоначального адресного пространства",
            "способ защититься от использования объектов одного класса вместо другого или по крайней мере управлять таким использованием",
            "положение теории типов, согласно которому имена (например, переменных) могут обозначать объекты разных (но имеющих общего родителя) классов"
        ],
        "correctAnswers": [
            "положение теории типов, согласно которому имена (например, переменных) могут обозначать объекты разных (но имеющих общего родителя) классов"
        ]
    },
    {
        "question": "Класс - это:",
        "choices": [
            "шаблон, на основе которого генерируются однотипные объекты",
            "множество объектов с общей структурой и поведением.",
            "нечто, чем можно оперировать"
        ],
        "correctAnswers": [
            "шаблон, на основе которого генерируются однотипные объекты"
        ]
    },
    {
        "question": "Поведение - это:",
        "choices": [
            "то, как объект действует и реагирует",
            "свойство объекта или такой набор свойств, который отличает его от всех других объектов",
            "перечень всех свойств данного объекта и текущими значениями каждого из этих свойств"
        ],
        "correctAnswers": [
            "свойство объекта или такой набор свойств, который отличает его от всех других объектов"
        ]
    },
    {
        "question": "Какие виды операций существуют?",
        "choices": [
            "интегратор",
            "модификатор",
            "селектор",
            "итератор"
        ],
        "correctAnswers": [
            "модификатор",
            "селектор",
            "итератор"
        ]
    },
    {
        "question": "Объект - это:",
        "choices": [
            "нечто, что поддается исследованию в каком-либо конкретном случае",
            "некоторый экземпляр, которым можно оперировать",
            "шаблон, на основе которого генерируются однотипные объекты"
        ],
        "correctAnswers": [
            "некоторый экземпляр, которым можно оперировать"
        ]
    },
    {
        "question": "Какие принципы проектирования более естественно и полно реализованы в ООП?",
        "choices": [
            "наследие",
            "поведение",
            "инкапсуляция",
            "полиморфизм"
        ],
        "correctAnswers": [
            "инкапсуляция",
            "полиморфизм"
        ]
    },
    {
        "question": "Инкапсуляция - это:",
        "choices": [
            "принцип, в соответствии с которым содержание внутреннего устройства элементов системы должно быть скрыто друг от друга",
            "принцип, в соответствии с которым знание об общей категории разрешается применять для более узкой",
            "положение теории типов, согласно которому имена могут обозначать объекты разных классов"
        ],
        "correctAnswers": [
            "принцип, в соответствии с которым содержание внутреннего устройства элементов системы должно быть скрыто друг от друга"
        ]
    },
    {
        "question": "Полиморфизм - это:",
        "choices": [
            "положение теории типов, согласно которому имена могут обозначать объекты разных классов",
            "принцип построения элементов модели так, чтобы они могли принимать различные внешние формы или функциональность (поведение) в зависимости от обстоятельств",
            "принцип, в соответствии с которым знание об общей категории разрешается применять для более узкой"
        ],
        "correctAnswers": [
            "принцип построения элементов модели так, чтобы они могли принимать различные внешние формы или функциональность (поведение) в зависимости от обстоятельств"
        ]
    },
    {
        "question": "Какие из перечисленных видов отношений существуют между классами?",
        "choices": [
            "отношение зависимости",
            "ассоциация",
            "отношение последовательности",
            "наследование"
        ],
        "correctAnswers": [
            "наследование"
        ]
    },
    {
        "question": "Обобщенный класс - это:",
        "choices": [
            "класс, который создан посредством шаблона",
            "класс, служащий шаблоном для создания других классов",
            "класс, экземпляры которого суть класса"
        ],
        "correctAnswers": [
            "класс, служащий шаблоном для создания других классов"
        ]
    }
]
